[
  {
    "objectID": "projects/project4.html",
    "href": "projects/project4.html",
    "title": "Project 4",
    "section": "",
    "text": "Project 4 focuses on understanding the mechanisms of immune remodeling in cervical cancer (CC) and identifying potential therapeutic targets; paper1, paper2. Cervical cancer progression involves complex interactions between immune cells and tumor cells, leading to an immunosuppressive microenvironment. To investigate these interactions, this study utilizes scRNA-seq data from normal cervix, high-grade squamous intraepithelial lesions (HSIL), and cervical cancer tissues to analyze transcriptional responses in immune cells.\nUnsupervised clustering of transcriptional profiles revealed distinct immune cell populations and their interactions with tumor cells. Differences in immune cell states were linked to the progression of cervical cancer and the establishment of an immunosuppressive microenvironment. Specifically, the study identified unique HPV-related epithelial clusters and critical node genes that regulate disease progression. The transition from normal cervix to HSIL and cervical cancer was marked by changes in immune cell populations, including T cells, dendritic cells, and macrophages.\nFurther analysis identified key immune cell subsets and their roles in shaping the tumor microenvironment. Network analyses demonstrated that immune cell interactions influence functional T cell programs and systemic immune coordination. This study provides insights into how immune remodeling impacts cervical cancer progression and highlights transcriptional markers that could be used to predict patient outcomes and guide therapeutic strategies."
  },
  {
    "objectID": "projects/project4.html#available-data",
    "href": "projects/project4.html#available-data",
    "title": "Project 4",
    "section": "Available data",
    "text": "Available data\nThese samples represent different stages and conditions of cervical tissues, providing a comprehensive dataset for analyzing the progression from normal cervix to cervical cancer.\n\nNormal Cervix without HPV (NO_HPV):\n\n\nN_HPV_NEG_1\nN_HPV_NEG_2\n\n\nNormal Cervix with HPV (N_HPV):\n\n\nN_1\nN_2\n\n\nHigh-Grade Squamous Intraepithelial Lesions with HPV (HSIL_HPV):\n\n\nHSIL_1\nHSIL_2\n\n\nCervical Cancer with HPV (CA_HPV):\n\n\nSCC_4\nSCC_5\nADC_6\n\nData has been downloaded and prepared for you from GEO GSE208653.\nIn order to download the data, run:\n\nwget https://single-cell-transcriptomics.s3.eu-central-1.amazonaws.com/projects/data/project4.tar.gz\ntar -xzvf project4.tar.gz\n\nAfter extracting, a directory project4 appears with the following content:\n.\n├── data\n│   ├── ADC_6\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── HSIL_1\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── HSIL_2\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── N_1\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── N_2\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── N_HPV_NEG_1\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── N_HPV_NEG_2\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── SCC_4\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   └── SCC_5\n│       ├── barcodes.tsv.gz\n│       ├── features.tsv.gz\n│       └── matrix.mtx.gz\n├── paper1.pdf\n└── paper2.pdf\n\n10 directories, 29 files\nNow create a new project in the project1 directory (Project (None) &gt; New Project …), and create Seurat object from the count matrices:\n\nlibrary(Seurat)\n# vector of paths to all sample directories\ndatadirs &lt;- list.files(path = \"data\", full.names = TRUE)\n\n# get the sample names\n# replace underscores with hyphen to correctly extract sample names later on\nnames(datadirs) &lt;- basename(datadirs) |&gt; gsub(\"_\", \"-\", x = _) \n\n# for now, we only take the HPV negative and cervical cancer samples\ndatadirs &lt;- datadirs[c(\"N-HPV-NEG-1\", \"N-HPV-NEG-2\", \"SCC-4\", \"SCC-5\")]\n\n# create a large sparse matrix from all count data\nsparse_matrix &lt;- Seurat::Read10X(data.dir = datadirs)\n\n# create a seurat object from sparse matrix\nseu &lt;- Seurat::CreateSeuratObject(counts = sparse_matrix,\n                                  project = \"CervicalCancerStudy\")\n\n\n\n\n\n\n\nProject exercise\n\n\n\nWith this dataset, go through the steps we have performed during the course, and try to reproduce the results provided in the paper. Pay specific attention to quality control, clustering and annotation."
  },
  {
    "objectID": "projects/project4.html#guidance-questions",
    "href": "projects/project4.html#guidance-questions",
    "title": "Project 4",
    "section": "Guidance questions",
    "text": "Guidance questions\nIf you’d like more structure, the following questions may guide your analyses:\nQuality control and filtering\n\nHow many cells are there in the data set (raw data)?\nIs there evidence of dying cells? If so, how can you filter for dying cells?\nHow does your filtering strategy compare with what was done in the two papers?\n\n\n\n\n\n\n\nBonus questions (advanced)\n\n\n\n\n\n\nWhy do you think paper 2 chose not to remove potential doublets?\nDo you think paper 1 or paper 2 chose a better threshold for removing cells based on high mitochondrial gene expression?\n\n\n\n\nNormalization & scaling\n\nWhich normalization strategy was used in the papers?\nHow many principal components would you suggest for downstream analyses?\nAre there batch-effects in this dataset? If so, how can you tell? How could you correct for batch effects?\nClustering & annotation\n\nWhich clustering resolution would you suggest for downstream analyses?\nWhich major cell types are you expecting for this dataset?\nWhich marker genes will you use for annotation?\nWhich clusters can you clearly identify using these markers genes?\n\n\n\n\n\n\n\nBonus questions (advanced)\n\n\n\n\n\n\nIf you didn’t have such a list of marker genes, which other techniques could you try?\nHow do these compare to manual annotation?"
  },
  {
    "objectID": "projects/project4.html#additional-tips",
    "href": "projects/project4.html#additional-tips",
    "title": "Project 4",
    "section": "Additional tips",
    "text": "Additional tips\n\nFor mitochondrial genes, ribosomol genes and hemoglobin genes you can use the following patterns: \"^MT-\", \"^RP[SL]\" and \"^HB[^(P)]\".\nWork iterative; meaning that based on results of an analyis, adjust the previous analysis. For example, if clustering is not according to cell types, try to adjust the number of components or the resolution.\nPlease read the methods section of the paper.\nIf the code for data analysis is available, try to adapt it (for specific parameters).\nCheck the supplementary figures.\nTry to understand if they used some other tools for the data analysis."
  },
  {
    "objectID": "projects/project2.html",
    "href": "projects/project2.html",
    "title": "Project 2",
    "section": "",
    "text": "Project 2 focuses on a single-cell sequencing study of the Drosophila brain following acute cocaine exposure; paper. Flies were exposed to cocaine, which impaired locomotor activity and increased the incidence of seizures and compulsive grooming. To investigate the specific cell populations responding to cocaine, single-cell transcriptional responses were analyzed in duplicate samples of flies that consumed sucrose or sucrose supplemented with cocaine. The study utilized the 10x Genomics Chromium platform for single-cell RNA sequencing.\nUnsupervised clustering of transcriptional profiles from 86,224 cells revealed 36 distinct clusters, representing all major cell types (neuronal and glial) and neurotransmitter types from most brain regions. Differential expression analysis within individual clusters indicated cluster-specific responses to cocaine, with Kenyon cells of the mushroom bodies and glia showing particularly large transcriptional changes. The study highlighted profound sexual dimorphism in brain transcriptional responses to cocaine, with males exhibiting more pronounced changes than females.\nCluster-specific coexpression networks and global interaction networks revealed diverse cellular processes affected by acute cocaine exposure, providing an atlas of sexually dimorphic cocaine-modulated gene expression in the Drosophila brain."
  },
  {
    "objectID": "projects/project2.html#available-data",
    "href": "projects/project2.html#available-data",
    "title": "Project 2",
    "section": "Available data",
    "text": "Available data\nData has been downloaded and prepared for you from GEO GSE152495.\nIn order to download the data, run:\n\nwget https://single-cell-transcriptomics.s3.eu-central-1.amazonaws.com/projects/data/project2.tar.gz\ntar -xzvf project2.tar.gz\n\nAfter extracting, a directory project2 appears with the following format:\n.\n├── data\n│   ├── Female_Cocaine_1\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── Female_Cocaine_2\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── Female_Sucrose_1\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── Female_Sucrose_2\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── Male_Cocaine_1\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── Male_Cocaine_2\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── Male_Sucrose_1\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   └── Male_Sucrose_2\n│       ├── barcodes.tsv.gz\n│       ├── features.tsv.gz\n│       └── matrix.mtx.gz\n└── paper.pdf\n\n9 directories, 25 files\nShowing us that we have two replicates per treatment, and two treatments:\n\nMale_Sucrose: controls\nFemale_Sucrose: controls\nMale_Cocaine: treatments\nFemale_Cocaine: treatments\n\nNow create a new project in the project2 directory (Project (None) &gt; New Project …), and create Seurat object from the count matrices:\n\nlibrary(Seurat)\n\n# vector of paths to all sample directories\ndatadirs &lt;- list.files(path = \"project2/data\", full.names = TRUE)\n\n# get the sample names and replace underscores with hyphens\nnames(datadirs) &lt;- basename(datadirs) |&gt; gsub(\"_\", \"-\", x = _)\n\n# create a large sparse matrix from all count data\nsparse_matrix &lt;- Seurat::Read10X(data.dir = datadirs)\n\n# create a seurat object from sparse matrix\nseu &lt;- Seurat::CreateSeuratObject(counts = sparse_matrix,\n                                  project = \"CocaineStudy\")\n\n\n\n\n\n\n\nProject exercise\n\n\n\nWith this dataset, go through the steps we have performed during the course, and try to reproduce the results provided in the paper."
  },
  {
    "objectID": "projects/project2.html#guidance-questions",
    "href": "projects/project2.html#guidance-questions",
    "title": "Project 2",
    "section": "Guidance questions",
    "text": "Guidance questions\nIf you’d like more structure, the following questions may guide your analyses:\n1. Quality Control (QC)\nThe paper does not provide explicit QC thresholds for filtering cells. You should use standard single-cell RNA-seq QC metrics and apply appropriate thresholds to filter out low-quality cells and genes.\n\n\nMitochondrial Genes: The paper uses the pattern \"^mt:\". Calculate the percentage of mitochondrial reads.\n\nRibosomal Genes: The paper uses the pattern \"^Rp[SL]\". Calculate the percentage of ribosomal reads.\n\nFiltering: Use a combination of the number of features per cell, UMI counts per cell, and the calculated mitochondrial and ribosomal percentages to filter the data.\n2. Data Normalization and Scaling\nThe paper mentions that transcriptional profiles were normalized by sequencing depth and log-transformed. This corresponds to the LogNormalize method in Seurat with a scale factor of 10,000. For scaling, the paper used SCTransform to regress out the effects of total UMI counts and mitochondrial genes.\n\n\nReproduce:\n\nFirst, normalize the data using NormalizeData with the LogNormalize method.\nThen, use SCTransform to scale the data and remove unwanted variation.\n\n\n3. Dimensionality Reduction\nThe paper used Principal Component Analysis (PCA) for linear dimensionality reduction and UMAP for nonlinear dimensionality reduction and visualization.\n\n\nReproduce:\n\nRun PCA on the scaled data.\nUse an Elbow Plot to determine the appropriate number of principal components to use for subsequent steps.\nRun UMAP on the selected principal components for 2D visualization of the data.\n\n\n4. Unsupervised Clustering\nThe paper used the Shared Nearest Neighbor (SNN) clustering algorithm. A crucial detail is that a resolution of 0.8 was found to be stable and yielded 36 distinct clusters, which is a key finding you should try to reproduce.\n\n\nReproduce:\n\nFind the nearest neighbors.\nApply the clustering algorithm with a resolution of 0.8 to identify the 36 clusters.\n\n\n5. Cluster Annotation\nAnnotate the 36 clusters by identifying top marker genes for each cluster. The paper provides specific filtering criteria for this analysis.\n\n\nReproduce:\n\nUse a function like FindAllMarkers to find marker genes for each cluster.\nFilter the marker genes using the paper’s criteria:\n\n\\(|log\\_{e}FC| \\&gt; 0.5\\)\nBonferroni-adjusted P-value &lt; 0.05\n\n\n\n\n6. Differential Expression (DE) Analysis\nThe paper performed differential expression analysis within individual clusters. You should compare gene expression between cocaine-exposed and sucrose-exposed flies within specific cell clusters.\n\n\nReproduce:\n\nUse a function like FindMarkers to compare the two conditions (Cocaine vs. Sucrose) within each cluster.\nFilter the results for strongly differentially expressed genes using the paper’s more stringent criteria:\n\n\\(|log\\_{e}FC| \\&gt; 1.0\\)\nBonferroni-adjusted P-value &lt; 0.05\n\n\n\n\n7. Analysis of Sexual Dimorphism\nSexual Dimorphism refers to the differences in gene expression between males and females in response to cocaine exposure. While males and females of a species share a core set of traits, they can also exhibit distinct characteristics. In the paper, the authors found that the genetic changes in the brain after cocaine exposure were much more significant and widespread in male flies compared to female flies. This difference in response between the sexes is “profound sexual dimorphism.” The study highlighted profound sexual dimorphism.\n\n\nReproduce:\n\nPerform a DE analysis between cocaine and sucrose conditions separately for male flies and female flies.\nCompare the results to see if male flies exhibit more widespread changes than females, as reported in the paper.\n\n\n8. Pathway Enrichment Analysis\nThe paper used Reactome for pathway enrichment analysis. You can use the R package clusterProfiler for this task. While the paper used Reactome, clusterProfiler is a popular tool that can perform enrichment analysis with various databases, including Reactome. You will need to ensure you have the appropriate Drosophila melanogaster gene annotation package for clusterProfiler to work correctly. To install a package, use the command renv::install(\"package-name\").\n\n\nReproduce:\n\nTake the list of differentially expressed genes from your DE analysis.\nPerform a pathway enrichment analysis using clusterProfiler to identify affected biological pathways."
  },
  {
    "objectID": "projects/project2.html#additional-tips",
    "href": "projects/project2.html#additional-tips",
    "title": "Project 2",
    "section": "Additional tips",
    "text": "Additional tips\nKey Figures and Tables to Compare\nAs you work through the analysis, you can compare your results to the following figures and tables from the paper:\n\n\nFigure 2: These figures show UMAP plots and cluster annotations. You can aim to reproduce a similar UMAP plot with 36 clusters.\n\nFigure 3: These figures show heatmaps and Euler plots of differentially expressed genes.\n\n\n\n\n\n\n\nImportant\n\n\n\nThe supplementary material of this paper contain a docx file with some data analysis code."
  },
  {
    "objectID": "projects/introduction.html",
    "href": "projects/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Download the presentation \n\n\nProject based learning is about learning by doing, but also about peer instruction. This means that you will be both a learner and a teacher. There will be differences in levels among participants, but because of that, some will learn efficiently from people that have just learned, and others will teach and increase their understanding.\nEach project has hints and guiding questions. However, if interesting questions pop up during the project, you are encouraged to work on those. Also, you don’t have to perform all the tasks and answer all the questions.\nYou will get to know each other, define how you like to collaborate and start on the project. On day 2 and 3 you can work on the project, and apply the skills and knowlege you have learned during these days. We will conclude the projects on day 3 with a 10-minute presentation of each group.\n\n\n\nEach group has access to a shared working directory, which is mounted at the root level as /group_work/groupX (replace X with your group number).\nIn RStudio Server, you can view the contents of your group’s directory in the Files pane (bottom left). Click on the three dots (...) to navigate to /group_work/groupX and access or manage your project files."
  },
  {
    "objectID": "projects/introduction.html#roles-organisation",
    "href": "projects/introduction.html#roles-organisation",
    "title": "Introduction",
    "section": "",
    "text": "Project based learning is about learning by doing, but also about peer instruction. This means that you will be both a learner and a teacher. There will be differences in levels among participants, but because of that, some will learn efficiently from people that have just learned, and others will teach and increase their understanding.\nEach project has hints and guiding questions. However, if interesting questions pop up during the project, you are encouraged to work on those. Also, you don’t have to perform all the tasks and answer all the questions.\nYou will get to know each other, define how you like to collaborate and start on the project. On day 2 and 3 you can work on the project, and apply the skills and knowlege you have learned during these days. We will conclude the projects on day 3 with a 10-minute presentation of each group."
  },
  {
    "objectID": "projects/introduction.html#working-directories",
    "href": "projects/introduction.html#working-directories",
    "title": "Introduction",
    "section": "",
    "text": "Each group has access to a shared working directory, which is mounted at the root level as /group_work/groupX (replace X with your group number).\nIn RStudio Server, you can view the contents of your group’s directory in the Files pane (bottom left). Click on the three dots (...) to navigate to /group_work/groupX and access or manage your project files."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SIB course Single Cell Transcriptomics",
    "section": "",
    "text": "Looking for original material?\n\n\n\nAre you looking for material of original SIB versions of the course? Find it at sib-swiss.github.io/single-cell-r-training"
  },
  {
    "objectID": "index.html#teachers",
    "href": "index.html#teachers",
    "title": "SIB course Single Cell Transcriptomics",
    "section": "Teachers",
    "text": "Teachers\n\nMichal Kolar ORCiD\nLucie Pfeiferova ORCiD\nJan Kubovciak ORCiD\nYusuf Caglar OdabasiORCiD"
  },
  {
    "objectID": "index.html#course-support-team",
    "href": "index.html#course-support-team",
    "title": "SIB course Single Cell Transcriptomics",
    "section": "Course support team",
    "text": "Course support team\n\nVojtech Melichar ORCiD\nMathys Delattre\nEva Rohlova\n\n\nGreat thanks to\n\nGeert van Geest ORCiD\nPatricia Palagi ORCiD"
  },
  {
    "objectID": "index.html#attribution",
    "href": "index.html#attribution",
    "title": "SIB course Single Cell Transcriptomics",
    "section": "Attribution",
    "text": "Attribution\nThis course is largely based on material from the SIB sib-swiss.github.io/single-cell-r-training, which we gratefully acknowledge. Parts of the original SIB Course were inspired by the Broad Institute Single Cell Workshop, the CRUK CI Introduction to single-cell RNA-seq data analysis course and courses previously developed by Walid Gharib at SIB."
  },
  {
    "objectID": "index.html#license-copyright",
    "href": "index.html#license-copyright",
    "title": "SIB course Single Cell Transcriptomics",
    "section": "License & copyright",
    "text": "License & copyright\nLicense: CC BY 4.0\nCopyright: SIB Swiss Institute of Bioinformatics"
  },
  {
    "objectID": "index.html#learning-outcomes",
    "href": "index.html#learning-outcomes",
    "title": "SIB course Single Cell Transcriptomics",
    "section": "Learning outcomes",
    "text": "Learning outcomes\n\nGeneral learning outcomes\nAt the end of the course, participants will be able to:\n\nDistinguish advantages and pitfalls of scRNA-seq, including its applications in experimental design.\nDesign their own scRNA-seq experiment, by using common technologies like 10X Genomics.\nApply quality control (QC) measures and utilize analysis tools to preprocess scRNA-seq data.\nApply normalization, scaling, dimensionality reduction, and integration and clustering on single-cell transcriptomics data techniques using R.\nDifferentiate between cell annotation techniques to identify and characterize cell populations.\nUse differential gene expression analysis methods on single-cell transcriptomics data to gain biological insights.\nSelect enrichment analysis methods appropriate to the biological question and data.\nDevelop a single-cell transcriptomics data analysis workflow from raw count matrix to differential gene expression with peer support and light guidance.\n\n\n\nLearning outcomes explained\nTo reach the general learning outcomes above, we have set a number of smaller learning outcomes. Each chapter starts with these smaller learning outcomes. Use these at the start of a chapter to get an idea what you will learn. Use them also at the end of a chapter to evaluate whether you have learned what you were expected to learn."
  },
  {
    "objectID": "index.html#learning-experiences",
    "href": "index.html#learning-experiences",
    "title": "SIB course Single Cell Transcriptomics",
    "section": "Learning experiences",
    "text": "Learning experiences\nTo reach the learning outcomes we will use lectures, exercises, polls and group work. During exercises, you are free to discuss with other participants. During lectures, focus on the lecture only.\n\nExercises\nEach block has practical work involved. Some more than others. The practicals are subdivided into chapters, and we’ll have a (short) discussion after each chapter. All answers to the practicals are incorporated, but they are hidden. Do the exercise first by yourself, before checking out the answer. If your answer is different from the answer in the practicals, try to figure out why they are different."
  },
  {
    "objectID": "day3/day3-2_differential_gene_expression.html",
    "href": "day3/day3-2_differential_gene_expression.html",
    "title": "Differential gene expression",
    "section": "",
    "text": "Download the presentation \n\n\nMore information on pseudobulk analysis\n\n\nMuscat for pseudobulk DGE.\n\nPaper on the robustness of different differential expression analysis methods"
  },
  {
    "objectID": "day3/day3-2_differential_gene_expression.html#material",
    "href": "day3/day3-2_differential_gene_expression.html#material",
    "title": "Differential gene expression",
    "section": "",
    "text": "Download the presentation \n\n\nMore information on pseudobulk analysis\n\n\nMuscat for pseudobulk DGE.\n\nPaper on the robustness of different differential expression analysis methods"
  },
  {
    "objectID": "day3/day3-2_differential_gene_expression.html#exercises",
    "href": "day3/day3-2_differential_gene_expression.html#exercises",
    "title": "Differential gene expression",
    "section": "Exercises",
    "text": "Exercises\nFind all markers for each cluster\nLoad the seu dataset you have created yesterday:\n\nseu &lt;- readRDS(\"day3/seu_day3-1.rds\")\n\nAnd load the following packages (install them if they are missing):\n\nlibrary(Seurat)\nlibrary(edgeR) # BiocManager::install(\"edgeR\")\nlibrary(limma)\nlibrary(dplyr)\nlibrary(scuttle)\n\nThe function FindAllMarkers performs a Wilcoxon test to determine the genes differentially expressed between each cluster and the rest of the cells. Other types of tests than the Wilcoxon test are available. Check it out by running ?Seurat::FindAllMarkers.\nNow run analysis:\n\nde_genes &lt;- Seurat::FindAllMarkers(seu,  min.pct = 0.25,\n                                   only.pos = TRUE)\n\nSubset the table to only keep the significant genes, and you can save it as a csv file if you wish to explore it further. Then extract the top 3 markers per cluster:\n\nde_genes &lt;- subset(de_genes, de_genes$p_val_adj &lt; 0.05)\nwrite.csv(de_genes,\n          \"day3/de_genes_FindAllMarkers.csv\",\n          row.names = F, quote = F)\n\ntop_specific_markers &lt;- de_genes %&gt;%\n  group_by(cluster) %&gt;%\n  top_n(3, avg_log2FC)\n\nAnd generate e.g. a dotplot:\n\ndittoSeq::dittoDotPlot(seu,\n                       vars = unique(top_specific_markers$gene), \n                       group.by = \"RNA_snn_res.0.3\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nWhat are significant marker genes in cluster 0 and 8? Are the T cell genes in there?\n\n\n\nYou can re-load the vector with immune genes with:\n\ntcell_genes &lt;- c(\"IL7R\", \"LTB\", \"TRAC\", \"CD3D\")\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nde_genes[de_genes$gene %in% tcell_genes,] |&gt; knitr::kable()\n\n\n\n\np_val\navg_log2FC\npct.1\npct.2\np_val_adj\ncluster\ngene\n\n\n\nCD3D\n0\n2.9015811\n0.771\n0.227\n0\n0\nCD3D\n\n\nTRAC\n0\n2.5835901\n0.628\n0.202\n0\n0\nTRAC\n\n\nLTB\n0\n1.8721406\n0.760\n0.394\n0\n0\nLTB\n\n\nIL7R\n0\n2.8988920\n0.438\n0.114\n0\n0\nIL7R\n\n\nLTB1\n0\n1.3821988\n0.677\n0.465\n0\n7\nLTB\n\n\nCD3D1\n0\n2.1253917\n0.801\n0.325\n0\n8\nCD3D\n\n\nTRAC1\n0\n2.3848920\n0.743\n0.274\n0\n8\nTRAC\n\n\nLTB2\n0\n1.8751545\n0.760\n0.462\n0\n8\nLTB\n\n\nIL7R1\n0\n1.8938862\n0.462\n0.172\n0\n8\nIL7R\n\n\nLTB3\n0\n0.9116856\n0.746\n0.466\n0\n10\nLTB\n\n\n\n\n\nSo, yes, the T-cell genes are highly significant markers for cluster 0 and 8.\n\n\n\nDifferential expression between groups of cells\nThe FindMarkers function allows to test for differential gene expression analysis specifically between 2 groups of cells, i.e. perform pairwise comparisons, eg between cells of cluster 0 vs cluster 2, or between cells annotated as T-cells and B-cells.\nFirst we can set the default cell identity to the cell types defined by SingleR:\n\nseu &lt;- Seurat::SetIdent(seu, value = \"SingleR_annot\")\n\nRun the differential gene expression analysis and subset the table to keep the significant genes:\n\ndeg_cd8_cd4 &lt;- Seurat::FindMarkers(seu,\n                                   ident.1 = \"CD8+ T cells\",\n                                   ident.2 = \"CD4+ T cells\",\n                                   group.by = seu$SingleR_annot,\n                                   test.use = \"wilcox\")\ndeg_cd8_cd4 &lt;- subset(deg_cd8_cd4, deg_cd8_cd4$p_val_adj&lt;0.05)\n\n\n\n\n\n\n\nExercise\n\n\n\nAre CD8A, CD8B and CD4 in there? What does the sign (i.e. positive or negative) mean in the log fold change values? Are they according to the CD8+ and CD4+ annotations? Check your answer by generating a violin plot of a top differentially expressed gene.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nYou can check out the results with:\n\nView(deg_cd8_cd4)\n\n\n\n\n\n\np_val\navg_log2FC\npct.1\npct.2\np_val_adj\n\n\n\nCD8A\n0.0e+00\n5.8036617\n0.336\n0.008\n0.0000000\n\n\nCTSW\n0.0e+00\n3.4118773\n0.276\n0.030\n0.0000000\n\n\nCCL5\n0.0e+00\n4.2922622\n0.285\n0.062\n0.0000000\n\n\nCD8B\n0.0e+00\n1.3123538\n0.470\n0.178\n0.0000000\n\n\nNKG7\n0.0e+00\n4.5376500\n0.225\n0.037\n0.0000000\n\n\nCST7\n0.0e+00\n4.4123574\n0.143\n0.012\n0.0000000\n\n\nGZMA\n0.0e+00\n3.8501654\n0.169\n0.025\n0.0000000\n\n\nTRGC2\n0.0e+00\n3.4931638\n0.144\n0.018\n0.0000000\n\n\nRPS27\n0.0e+00\n-0.1820605\n1.000\n1.000\n0.0000000\n\n\nKLRD1\n0.0e+00\n4.3589947\n0.108\n0.008\n0.0000000\n\n\nID2\n0.0e+00\n0.8632969\n0.565\n0.353\n0.0000000\n\n\nGZMK\n0.0e+00\n3.0113231\n0.130\n0.022\n0.0000000\n\n\nHCST\n0.0e+00\n0.7949700\n0.681\n0.495\n0.0000000\n\n\nMT-CO1\n0.0e+00\n0.3243268\n0.989\n0.979\n0.0000000\n\n\nTRGC1\n0.0e+00\n3.6853476\n0.110\n0.013\n0.0000000\n\n\nFHIT\n0.0e+00\n-1.6706990\n0.110\n0.273\n0.0000000\n\n\nRP11-291B21.2\n0.0e+00\n1.3507107\n0.222\n0.077\n0.0000000\n\n\nMT-ND4\n0.0e+00\n0.3226206\n0.963\n0.932\n0.0000000\n\n\nCD4\n0.0e+00\n-3.3247772\n0.011\n0.105\n0.0000000\n\n\nMT-CO2\n0.0e+00\n0.2401784\n0.993\n0.995\n0.0000000\n\n\nTRDC\n0.0e+00\n2.6894608\n0.105\n0.019\n0.0000000\n\n\nCRTAM\n0.0e+00\n3.7124154\n0.068\n0.003\n0.0000000\n\n\nPECAM1\n0.0e+00\n2.6701767\n0.096\n0.015\n0.0000000\n\n\nLYAR\n0.0e+00\n1.6580580\n0.198\n0.076\n0.0000000\n\n\nGZMH\n0.0e+00\n4.8543018\n0.067\n0.003\n0.0000000\n\n\nPRF1\n0.0e+00\n2.8596139\n0.099\n0.018\n0.0000000\n\n\nACTB\n0.0e+00\n0.3093718\n0.965\n0.925\n0.0000000\n\n\nAC092580.4\n0.0e+00\n1.3359936\n0.173\n0.061\n0.0000000\n\n\nCCL4\n0.0e+00\n3.7724347\n0.118\n0.031\n0.0000001\n\n\nRPS27A\n0.0e+00\n-0.1605123\n1.000\n1.000\n0.0000001\n\n\nRPL11\n0.0e+00\n-0.1685948\n1.000\n1.000\n0.0000002\n\n\nKLRC1\n0.0e+00\n8.3089065\n0.048\n0.000\n0.0000004\n\n\nMT-CO3\n0.0e+00\n0.2753652\n0.966\n0.954\n0.0000005\n\n\nTPST2\n0.0e+00\n1.8352805\n0.137\n0.045\n0.0000009\n\n\nRUNX3\n0.0e+00\n1.0535174\n0.180\n0.071\n0.0000009\n\n\nHLA-B\n0.0e+00\n0.3203112\n0.970\n0.934\n0.0000012\n\n\nRPL21\n0.0e+00\n-0.1713527\n1.000\n1.000\n0.0000012\n\n\nMT-ND2\n0.0e+00\n0.2971960\n0.958\n0.918\n0.0000013\n\n\nRPS29\n0.0e+00\n-0.1172011\n1.000\n1.000\n0.0000032\n\n\nGNLY\n0.0e+00\n3.8610459\n0.132\n0.046\n0.0000038\n\n\nIL32\n0.0e+00\n0.5401192\n0.739\n0.624\n0.0000060\n\n\nFAM173A\n0.0e+00\n1.1506784\n0.194\n0.087\n0.0000076\n\n\nNR4A2\n0.0e+00\n0.8415276\n0.341\n0.203\n0.0000094\n\n\nIL2RB\n0.0e+00\n2.2000968\n0.078\n0.015\n0.0000148\n\n\nHOPX\n0.0e+00\n2.3701004\n0.089\n0.022\n0.0000197\n\n\nCXCR3\n0.0e+00\n2.4269612\n0.072\n0.013\n0.0000234\n\n\nRPL30\n0.0e+00\n-0.1749260\n0.992\n0.998\n0.0000259\n\n\nPLEK\n0.0e+00\n2.7963063\n0.059\n0.008\n0.0000327\n\n\nCBLB\n0.0e+00\n1.2237121\n0.127\n0.045\n0.0000494\n\n\nRPS25\n0.0e+00\n-0.1727553\n1.000\n1.000\n0.0000532\n\n\nBZW1\n0.0e+00\n0.7778875\n0.354\n0.223\n0.0000597\n\n\nRPL34\n0.0e+00\n-0.1552375\n1.000\n1.000\n0.0000684\n\n\nMT-ND3\n0.0e+00\n0.2539291\n0.955\n0.930\n0.0000920\n\n\nACTG1\n0.0e+00\n0.4120757\n0.744\n0.622\n0.0001017\n\n\nRPL31\n0.0e+00\n-0.1426997\n1.000\n0.998\n0.0001340\n\n\nCD160\n0.0e+00\n4.6296720\n0.042\n0.002\n0.0001448\n\n\nNT5E\n0.0e+00\n4.1692640\n0.042\n0.002\n0.0001452\n\n\nTRAT1\n0.0e+00\n-1.2378085\n0.135\n0.242\n0.0001694\n\n\nRPL35A\n0.0e+00\n-0.1498209\n0.999\n0.999\n0.0001911\n\n\nRPL32\n0.0e+00\n-0.1349986\n1.000\n1.000\n0.0001959\n\n\nMAL\n0.0e+00\n-1.0983742\n0.149\n0.257\n0.0001977\n\n\nMATK\n0.0e+00\n1.5714195\n0.092\n0.026\n0.0002149\n\n\nCD40LG\n0.0e+00\n-1.9356543\n0.020\n0.087\n0.0002240\n\n\nTGFBR3\n0.0e+00\n3.2149127\n0.047\n0.004\n0.0003054\n\n\nCLIC3\n0.0e+00\n2.7202513\n0.054\n0.008\n0.0004215\n\n\nJUN\n0.0e+00\n0.5742398\n0.681\n0.588\n0.0004373\n\n\nKLRC4\n0.0e+00\n3.3549690\n0.048\n0.005\n0.0005192\n\n\nRPS23\n0.0e+00\n-0.1485187\n1.000\n1.000\n0.0005639\n\n\nTMSB10\n0.0e+00\n-0.1783588\n0.996\n0.999\n0.0006274\n\n\nIFRD1\n0.0e+00\n0.7876254\n0.303\n0.182\n0.0006301\n\n\nICOS\n1.0e-07\n-1.8295856\n0.035\n0.107\n0.0009510\n\n\nMT-ATP6\n1.0e-07\n0.2791020\n0.932\n0.902\n0.0009630\n\n\nXCL2\n1.0e-07\n5.1473347\n0.035\n0.001\n0.0009734\n\n\nLITAF\n1.0e-07\n0.6455639\n0.407\n0.277\n0.0010564\n\n\nKLRC2\n1.0e-07\n4.5769235\n0.038\n0.002\n0.0011382\n\n\nLAG3\n1.0e-07\n2.6152771\n0.054\n0.009\n0.0012129\n\n\nKLRG1\n1.0e-07\n1.8532056\n0.103\n0.037\n0.0013752\n\n\nIFNG\n1.0e-07\n3.4727589\n0.051\n0.008\n0.0013816\n\n\nRPS15A\n1.0e-07\n-0.1390132\n1.000\n1.000\n0.0014859\n\n\nMT1F\n1.0e-07\n1.8145433\n0.086\n0.026\n0.0015767\n\n\nS100B\n1.0e-07\n2.0010809\n0.105\n0.038\n0.0018264\n\n\nLCP1\n1.0e-07\n0.7192442\n0.312\n0.198\n0.0021165\n\n\nMT-CYB\n1.0e-07\n0.2155921\n0.959\n0.958\n0.0021248\n\n\nGZMB\n1.0e-07\n4.7551476\n0.037\n0.002\n0.0021433\n\n\nHLA-DPB1\n2.0e-07\n0.9458630\n0.210\n0.113\n0.0028339\n\n\nMAP3K8\n2.0e-07\n2.3308513\n0.058\n0.012\n0.0037843\n\n\nSTK17A\n3.0e-07\n0.6044699\n0.426\n0.306\n0.0049752\n\n\nZFP36\n3.0e-07\n0.6981065\n0.394\n0.276\n0.0052431\n\n\nA1BG\n3.0e-07\n0.9879067\n0.147\n0.068\n0.0052530\n\n\nACTN4\n3.0e-07\n1.6884121\n0.074\n0.021\n0.0057168\n\n\nGZMM\n3.0e-07\n0.5590226\n0.354\n0.231\n0.0057598\n\n\nRPL13A\n3.0e-07\n-0.1027637\n1.000\n1.000\n0.0062383\n\n\nABCB1\n4.0e-07\n2.0901339\n0.057\n0.012\n0.0067877\n\n\nDUSP2\n4.0e-07\n1.0251535\n0.319\n0.213\n0.0069206\n\n\nARPC5L\n4.0e-07\n0.8444989\n0.173\n0.087\n0.0071525\n\n\nCORO1B\n4.0e-07\n-1.2457970\n0.122\n0.209\n0.0072482\n\n\nC12orf75\n5.0e-07\n0.9457620\n0.200\n0.111\n0.0086192\n\n\nRPL18\n5.0e-07\n-0.1498451\n0.982\n0.988\n0.0088652\n\n\nRPS8\n5.0e-07\n-0.1596945\n1.000\n0.999\n0.0091967\n\n\nB2M\n5.0e-07\n0.1532571\n1.000\n1.000\n0.0095932\n\n\nMT-ND1\n5.0e-07\n0.2998300\n0.843\n0.791\n0.0098249\n\n\nRPL37\n6.0e-07\n-0.1315823\n0.999\n0.999\n0.0103264\n\n\nTSPAN32\n6.0e-07\n1.2568587\n0.123\n0.054\n0.0103422\n\n\nGPR183\n6.0e-07\n-0.9248264\n0.116\n0.209\n0.0103973\n\n\nCCR7\n6.0e-07\n-0.8769143\n0.244\n0.343\n0.0113471\n\n\nSRGN\n6.0e-07\n0.7042011\n0.467\n0.360\n0.0117323\n\n\nRPL5\n7.0e-07\n-0.1568235\n0.983\n0.989\n0.0121481\n\n\nRPL38\n7.0e-07\n-0.1604085\n0.989\n0.993\n0.0123553\n\n\nCYBA\n7.0e-07\n0.4154226\n0.680\n0.582\n0.0136535\n\n\nDUSP1\n8.0e-07\n0.5137168\n0.688\n0.582\n0.0155765\n\n\nTBX21\n9.0e-07\n3.9258636\n0.033\n0.002\n0.0168414\n\n\nXCL1\n9.0e-07\n4.2021279\n0.033\n0.002\n0.0169279\n\n\nLINC00152\n1.1e-06\n1.4174424\n0.102\n0.041\n0.0197132\n\n\nHLA-A\n1.1e-06\n0.3019478\n0.891\n0.845\n0.0198546\n\n\nNSMAF\n1.1e-06\n1.5192786\n0.067\n0.019\n0.0207285\n\n\nSCCPDH\n1.2e-06\n1.6248603\n0.068\n0.020\n0.0218906\n\n\nRPS17\n1.2e-06\n-0.1449256\n0.999\n0.999\n0.0226365\n\n\nNCR3\n1.4e-06\n1.5189519\n0.074\n0.023\n0.0254304\n\n\nHLA-C\n1.8e-06\n0.2515121\n0.907\n0.859\n0.0341751\n\n\nTSPYL2\n1.9e-06\n0.5852828\n0.269\n0.168\n0.0349308\n\n\nAP3M2\n2.0e-06\n-1.6253908\n0.071\n0.143\n0.0370676\n\n\nPRR5\n2.1e-06\n1.9492113\n0.075\n0.025\n0.0399115\n\n\nRPL36A\n2.3e-06\n-0.2223425\n0.989\n0.990\n0.0436935\n\n\nFCRL6\n2.5e-06\n6.1868906\n0.024\n0.000\n0.0464487\n\n\nADTRP\n2.5e-06\n-2.8470196\n0.010\n0.053\n0.0466904\n\n\nBIRC3\n2.6e-06\n-1.4864265\n0.071\n0.143\n0.0489079\n\n\n\n\n\nFor an explanation of the log fold change have a look at ?Seurat::FindMarkers. At Value it says:\n\navg_logFC: log fold-chage of the average expression between the two groups. Positive values indicate that the gene is more highly expressed in the first group\n\nTo view CD8A, CD8B and CD4:\n\ndeg_cd8_cd4[c(\"CD4\", \"CD8A\", \"CD8B\"),]\n\n            p_val avg_log2FC pct.1 pct.2    p_val_adj\nCD4  2.290800e-14  -3.324777 0.011 0.105 4.277611e-10\nCD8A 2.889582e-74   5.803662 0.336 0.008 5.395717e-70\nCD8B 3.756143e-34   1.312354 0.470 0.178 7.013846e-30\n\n\nIndeed, because we compared ident.1 = “CD8+ T cells” to ident.2 = “CD4+ T cells”, a negative log2FC for the CD4 gene indicates a lower expression in CD8+ T-cells than in CD4+ T-cells, while a positive log2FC for the CD8A and CD8B genes indicates a higher expression in CD8+ T-cells.\nPlotting the genes in these two T-cell groups only:\n\nSeurat::VlnPlot(seu, \n            features = c(\"CD4\", \"CD8A\", \"CD8B\"),\n            idents = c(\"CD8+ T cells\", \"CD4+ T cells\"))\n\n\n\n\n\n\n\n\n\n\nDifferential expression using limma\n\nThe Wilcoxon test implemented in FindMarkers does not allow you to test for complex design (eg factorial experiments) or to include batch as a covariate. It doesn’t allow you to run paired-sample T tests for example.\nFor more complex designs, we can use edgeR or limma which are designed for microarray or bulk RNA seq data and provide a design matrix that includes covariates for example, or sample IDs for paired analyses.\nWe will load an object containing only pro B cells, both from healthy tissues (PBMMC), and malignant tissues (ETV6-RUNX1).\n\n\n\n\n\n\nWarning\n\n\n\nPlease NOTE that in the original design of this data set, the healthy and malignant tissues were not patient-matched, i.e. the real design was not the one of paired healthy and malignant tissues. However, for demonstration purposes, we will show you how to run a paired analysis, and do as if the PBMMC-1 and ETV6-RUNX1-1 samples both came from the same patient 1, the PBMMC-2 and ETV6-RUNX1-2 samples both came from the same patient 2, etc…\n\n\nWe can load the object and explore its UMAP and meta.data like this:\n\nproB &lt;- readRDS(\"course_data/proB.rds\")\n\nSeurat::DimPlot(proB, group.by = \"orig.ident\")\n\n\n\n\n\n\ntable(proB@meta.data$type)\n\n\nETV6-RUNX1      PBMMC \n      2000       1021 \n\nhead(proB@meta.data)\n\n                           orig.ident nCount_RNA nFeature_RNA    SingleR_annot\nPBMMC-1_AAATGCCAGACTGGGT-1    PBMMC-1       4886         1727 Pro-B_cell_CD34+\nPBMMC-1_AAATGCCTCCACTGGG-1    PBMMC-1       8397         2291 Pro-B_cell_CD34+\nPBMMC-1_AACACGTTCTTGACGA-1    PBMMC-1       3444         1204 Pro-B_cell_CD34+\nPBMMC-1_AACCATGAGAAGGTGA-1    PBMMC-1       8981         2437 Pro-B_cell_CD34+\nPBMMC-1_AACCGCGCATGGTCAT-1    PBMMC-1       3719         1368 Pro-B_cell_CD34+\nPBMMC-1_AAGCCGCCAGACGTAG-1    PBMMC-1       4573         1464 Pro-B_cell_CD34+\n                            type\nPBMMC-1_AAATGCCAGACTGGGT-1 PBMMC\nPBMMC-1_AAATGCCTCCACTGGG-1 PBMMC\nPBMMC-1_AACACGTTCTTGACGA-1 PBMMC\nPBMMC-1_AACCATGAGAAGGTGA-1 PBMMC\nPBMMC-1_AACCGCGCATGGTCAT-1 PBMMC\nPBMMC-1_AAGCCGCCAGACGTAG-1 PBMMC\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you want to know how this pro-B cell subset is generated, have a look at the script here.\n\n\nLet’s have a look at the UMAP (again), coloured by celltype:\n\nSeurat::DimPlot(proB, group.by = \"type\")\n\n\n\n\n\n\n\nLet’s say we are specifically interested to test for differential gene expression between the tumor and normal samples.\n\n\n\n\n\n\nNote\n\n\n\nHere we could also test for e.g. healthy versus diseased within a celltype/cluster.\n\n\nNow we will run differential expression analysis between tumor and healthy cells using the patient ID as a covariate by using limma.\nPrepare the pseudobulk count matrix:\n\n#taking the proB data \nSeurat::DefaultAssay(proB) &lt;- \"RNA\"\nSeurat::Idents(proB) &lt;- proB$orig.ident\n\n## add the patient id also for paired DGE\nproB$patient.id&lt;-gsub(\"ETV6-RUNX1\", \"ETV6_RUNX1\", proB$orig.ident)\nproB$patient.id&lt;-sapply(strsplit(proB$patient.id, \"-\"), '[', 2)\n\n## Here we do perform pseudo-bulk:\n##first a mandatory column of sample needs to be added to the meta data that is the grouping factor, should be the samples\nproB$sample &lt;- factor(proB$orig.ident)\n\n# aggergate the cells per sampple\nbulk &lt;- Seurat::AggregateExpression(proB, group.by = \"sample\",\n                                    return.seurat = TRUE,\n                                    assay = \"RNA\")\n\n# create a metadata data frame based on the aggregated cells\nmeta_data &lt;- unique(proB@meta.data[, c(\"orig.ident\",\n                                            \"sample\", \"type\",\n                                            \"patient.id\")])\nrownames(meta_data) &lt;- meta_data$orig.ident\nbulk@meta.data &lt;- meta_data[colnames(bulk), ]\n\n\n##have a look at the counts\ncounts &lt;- Seurat::GetAssayData(bulk, layer = \"counts\") |&gt; as.matrix()\n\nhead(counts)\n\n              ETV6-RUNX1-1 ETV6-RUNX1-2 ETV6-RUNX1-3 PBMMC-1 PBMMC-2 PBMMC-3\nRP11-34P13.7             0            0            0       2       0       0\nFO538757.3               0            0            0       0       0       0\nFO538757.2             138          275           74     129      40     112\nAP006222.2              63           43           17      38      19      26\nRP4-669L17.10            5           10            3       0       1       1\nRP5-857K21.4             0            0            0       0       0       2\n\n#have a look at the colData of our new object summed, can you see type and \n#patient.id are there\nhead(bulk@meta.data)\n\n               orig.ident       sample       type patient.id\nETV6-RUNX1-1 ETV6-RUNX1-1 ETV6-RUNX1-1 ETV6-RUNX1          1\nETV6-RUNX1-2 ETV6-RUNX1-2 ETV6-RUNX1-2 ETV6-RUNX1          2\nETV6-RUNX1-3 ETV6-RUNX1-3 ETV6-RUNX1-3 ETV6-RUNX1          3\nPBMMC-1           PBMMC-1      PBMMC-1      PBMMC          1\nPBMMC-2           PBMMC-2      PBMMC-2      PBMMC          2\nPBMMC-3           PBMMC-3      PBMMC-3      PBMMC          3\n\n\nGenerate a DGEList object to use as input for limma and filter the genes to remove lowly expressed genes. How many are left?\n\n#As in the standard limma analysis generate a DGE object\n\ny &lt;- edgeR::DGEList(counts, samples = bulk@meta.data)\n\n##filter lowly expressed (recommanded for limma)\nkeep &lt;- edgeR::filterByExpr(y, group = bulk$type)\ny &lt;- y[keep,]\n\n##see how many genes were kept \nsummary(keep)\n\n   Mode   FALSE    TRUE \nlogical   11086   10017 \n\n\nGenerate a design matrix, including patient ID to model for a paired analysis. If you need help to generate a design matrix, check out the very nice edgeR User Guide, sections 3.3 and 3.4. Extract the sample ID from the meta.data, then create the design matrix:\n\n## Create the design matrix and include the technology as a covariate:\ndesign &lt;- model.matrix(~0 + y$samples$type + y$samples$patient.id)\n\n# Have a look\ndesign\n\n  y$samples$typeETV6-RUNX1 y$samples$typePBMMC y$samples$patient.id2\n1                        1                   0                     0\n2                        1                   0                     1\n3                        1                   0                     0\n4                        0                   1                     0\n5                        0                   1                     1\n6                        0                   1                     0\n  y$samples$patient.id3\n1                     0\n2                     0\n3                     1\n4                     0\n5                     0\n6                     1\nattr(,\"assign\")\n[1] 1 1 2 2\nattr(,\"contrasts\")\nattr(,\"contrasts\")$`y$samples$type`\n[1] \"contr.treatment\"\n\nattr(,\"contrasts\")$`y$samples$patient.id`\n[1] \"contr.treatment\"\n\n# change column/rownames names to more simple group names: \ncolnames(design) &lt;- make.names(c(\"ETV6-RUNX1\", \"PBMMC\",\"patient2\",\"patient3\"))\nrownames(design) &lt;- rownames(y$samples)\n\nSpecify which contrast to analyse:\n\ncontrast.mat &lt;- limma::makeContrasts(ETV6.RUNX1 - PBMMC,\n                                     levels = design)\n\nFirt, we perform TMM normalization using edgeR, and then limma can perform the transformation with voom, fit the model, compute the contrasts and compute test statistics with eBayes:\n\ndge &lt;- edgeR::calcNormFactors(y)  \n\n#Do limma\nvm &lt;- limma::voom(dge, design = design)\nfit &lt;- limma::lmFit(vm, design = design)\nfit.contrasts &lt;- limma::contrasts.fit(fit, contrast.mat)\nfit.contrasts &lt;- limma::eBayes(fit.contrasts)\n\nWe can use topTable to get the most significantly differentially expressed genes, and save the full DE results to an object. How many genes are significant? Are you suprised by this number?\n\n# Show the top differentially expressed genes:\nlimma::topTable(fit.contrasts, number = 10, sort.by = \"P\")\n\n               logFC  AveExpr         t      P.Value    adj.P.Val        B\nRPS4Y2      5.346800 6.347826  15.39674 3.361453e-08 0.0001152727 9.477129\nSDC2        9.070465 2.708711  15.33434 3.493119e-08 0.0001152727 7.681010\nIGLL1      -3.788160 9.287148 -15.19483 3.808426e-08 0.0001152727 9.465422\nCTGF        4.368363 6.029640  14.89301 4.603081e-08 0.0001152727 9.141505\nAP005530.2  8.770808 2.560369  14.27130 6.879238e-08 0.0001335825 7.294079\nGNG11       3.500250 6.457777  13.70183 1.008304e-07 0.0001335825 8.495288\nHLA-DQA1    2.982748 7.410939  13.39202 1.249067e-07 0.0001335825 8.287394\nPTP4A3      3.734865 5.449894  13.23439 1.395246e-07 0.0001335825 8.126807\nCD27        4.115561 5.843582  13.23011 1.399471e-07 0.0001335825 8.147433\nALOX5       4.142010 5.682900  13.16658 1.463814e-07 0.0001335825 8.098199\n\nlimma_de &lt;- limma::topTable(fit.contrasts, number = Inf, sort.by = \"P\")\nlength(which(limma_de$adj.P.Val&lt;0.05))\n\n[1] 2738\n\n\nAnd we can check whether this corresponds to the counts by generating a violin plot, or a gene downregulated in tumor, or a gene upregulated in tumor:\n\nSeurat::VlnPlot(proB, \"S100A9\", split.by = \"type\")\n\n\n\n\n\n\nSeurat::VlnPlot(proB, \"SOCS2\", split.by = \"type\")"
  },
  {
    "objectID": "day3/day3-2_differential_gene_expression.html#some-qc-plots",
    "href": "day3/day3-2_differential_gene_expression.html#some-qc-plots",
    "title": "Differential gene expression",
    "section": "Some QC plots",
    "text": "Some QC plots\nHistogram of p-values\n\nlibrary(ggplot2)\n\nggplot(limma_de, aes(x = adj.P.Val)) +\n  geom_histogram(binwidth = 0.01, fill = \"skyblue\", color = \"black\") +\n  theme_minimal() +\n  labs(\n    title = \"Histogram of Adjusted P-values\",\n    x = \"Adjusted P-value\",\n    y = \"Frequency (Number of Genes)\"\n  ) +\n  geom_vline(xintercept = 0.05, linetype = \"dashed\", color = \"red\") +\n  annotate(\"text\", x = 0.07, y = max(hist(limma_de$adj.P.Val, plot = FALSE)$counts) * 0.9,\n           label = \"FDR = 0.05\", color = \"red\", hjust = 0)\n\n\n\n\n\n\n\nA “healthy” histogram is L-shaped, with a high bar at 0 and then relatively flat. If your histogram looks like that, your statistical testing has likely performed well. Read more about distribution of histogram p-value: How to interpret a p-value histogram\nMA plot\n\nsig_threshold_adj_p &lt;- 0.05\nsig_threshold_logFC &lt;- 1\nlimma_de_ma_plot &lt;- limma_de %&gt;%\n  mutate(\n    is_significant = case_when(\n      adj.P.Val &lt; sig_threshold_adj_p & logFC &gt; sig_threshold_logFC ~ \"Upregulated\",\n      adj.P.Val &lt; sig_threshold_adj_p & logFC &lt; -sig_threshold_logFC ~ \"Downregulated\",\n      TRUE ~ \"Not Significant\"\n    ),\n    gene_label = ifelse(abs(logFC) &gt; 5 | (adj.P.Val &lt; 1e-5 & abs(logFC) &gt; 3), rownames(limma_de), NA)\n  )\n\nggplot(limma_de_ma_plot, aes(x = AveExpr, y = logFC, color = is_significant)) +\n  geom_point(alpha = 0.6, size = 1) + \n  scale_color_manual(values = c(\"Upregulated\" = \"red\", \"Downregulated\" = \"blue\", \"Not Significant\" = \"grey\")) +\n  theme_minimal() +\n  labs(\n    title = \"MA Plot\",\n    x = \"Average Expression (log2)\",\n    y = \"Log2 Fold Change\",\n    color = \"Significance\"\n  ) +\n  geom_hline(yintercept = c(-sig_threshold_logFC, sig_threshold_logFC), linetype = \"dashed\", color = \"darkgreen\") +\n  geom_hline(yintercept = 0, linetype = \"solid\", color = \"black\") +\n  geom_text(aes(label = gene_label), na.rm = TRUE, size = 3, hjust = -0.1, vjust = 0.5, check_overlap = TRUE)\n\n\n\n\n\n\n\nA “healthy” MA plot is symmetrical around the logFC = 0 line, with most points tightly clustered near zero logFC at high average expression (AveExpr), and a wider spread at low average expression. This indicates no systematic biases and effective detection of differential expression."
  },
  {
    "objectID": "day3/day3-2_differential_gene_expression.html#differential-analysis-using-seurat",
    "href": "day3/day3-2_differential_gene_expression.html#differential-analysis-using-seurat",
    "title": "Differential gene expression",
    "section": "Differential analysis using Seurat\n",
    "text": "Differential analysis using Seurat\n\nWe can run a similar analysis with Seurat, but this will not take into account the paired design. Run the code below.\n\ntum_vs_norm &lt;- Seurat::FindMarkers(proB, \n                                   ident.1 = \"ETV6-RUNX1\", \n                                   ident.2 = \"PBMMC\", \n                                   group.by = \"type\")\ntum_vs_norm_s &lt;- subset(tum_vs_norm, tum_vs_norm$p_val_adj&lt;0.05)\n\n\n\n\n\n\n\nExercise (extra)\n\n\n\nHow many genes are significant? How does the fold change of these genes compare to the fold change of the top genes found by limma?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ndim(tum_vs_norm_s) \n\n[1] 3820    5\n\n\nWe find 3820 significant genes.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCan you now try to make histogram of p-values from Seurat analysis?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(ggplot2)\n\nggplot(tum_vs_norm, aes(x = p_val_adj)) +\n  geom_histogram(binwidth = 0.01, fill = \"skyblue\", color = \"black\") +\n  theme_minimal() +\n  labs(\n    title = \"Histogram of Adjusted P-values\",\n    x = \"Adjusted P-value\",\n    y = \"Frequency (Number of Genes)\"\n  ) +\n  geom_vline(xintercept = 0.05, linetype = \"dashed\", color = \"red\") +\n  annotate(\"text\", x = 0.07, y = max(hist(tum_vs_norm$p_val_adj, plot = FALSE)$counts) * 0.9,\n           label = \"FDR = 0.05\", color = \"red\", hjust = 0)\n\n\n\n\n\n\n\nMany differential expression tests (including those implemented in Seurat, like Wilcoxon Rank Sum test) will not compute a p-value for genes that are expressed in too few cells in one or both of the groups being compared."
  },
  {
    "objectID": "day3/day3-2_differential_gene_expression.html#comparison-of-results-between-seurat-and-limma",
    "href": "day3/day3-2_differential_gene_expression.html#comparison-of-results-between-seurat-and-limma",
    "title": "Differential gene expression",
    "section": "Comparison of results between Seurat and limma\n",
    "text": "Comparison of results between Seurat and limma\n\nIf we merge the FindMarkers and the limma results, keep limma’s most significant genes and plot:\n\nmerge_limma_FindMarkers &lt;- merge(tum_vs_norm_s, limma_de, by=\"row.names\",\n                           all.x=T)\n\npar(mar=c(4,4,4,4))\nplot(merge_limma_FindMarkers$avg_log2FC,\n    merge_limma_FindMarkers$logFC,\n    xlab=\"log2FC Wilcoxon\", ylab=\"log2FC limma\",\n    pch=15, cex=0.5)\nabline(a=0, b=1, col=\"red\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nKeep the object\n\n\n\nKeep the tum_vs_norm and limma_de objects because we will use this output later for the enrichment analysis in the next section."
  },
  {
    "objectID": "day2/day2-4_clustering.html",
    "href": "day2/day2-4_clustering.html",
    "title": "Clustering",
    "section": "",
    "text": "Download the presentation \n\n Download the presentation from the video \n\nEvaluation of clustering methods"
  },
  {
    "objectID": "day2/day2-4_clustering.html#material",
    "href": "day2/day2-4_clustering.html#material",
    "title": "Clustering",
    "section": "",
    "text": "Download the presentation \n\n Download the presentation from the video \n\nEvaluation of clustering methods"
  },
  {
    "objectID": "day2/day2-4_clustering.html#exercises",
    "href": "day2/day2-4_clustering.html#exercises",
    "title": "Clustering",
    "section": "Exercises",
    "text": "Exercises\nLoad the seu dataset you have created earlier today:\n\nseu &lt;- readRDS(\"day2/seu_day2-3.rds\")\n\nThe method implemented in Seurat first constructs a SNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors() function, and takes as input the previously defined dimensionality of the dataset.\n\nseu &lt;- Seurat::FindNeighbors(seu, dims = 1:25, reduction = \"integrated.cca\")\n\nTo cluster the cells, Seurat next implements modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function. The FindClusters() function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters.\n\nseu &lt;- Seurat::FindClusters(seu, resolution = seq(0.1, 0.8, by=0.1))\n\nCluster id of each cell is added to the metadata object, as a new column for each resolution tested:\n\nhead(seu@meta.data)\n\n                           orig.ident nCount_RNA nFeature_RNA percent.mito\nPBMMC-1_AAACCTGCAGACGCAA-1    PBMMC-1       2401          909     2.540608\nPBMMC-1_AAACCTGTCATCACCC-1    PBMMC-1       3532          760     5.181200\nPBMMC-1_AAAGATGCATAAAGGT-1    PBMMC-1       3972         1215     4.934542\nPBMMC-1_AAAGCAAAGCAGCGTA-1    PBMMC-1       3569          894     3.250210\nPBMMC-1_AAAGCAACAATAACGA-1    PBMMC-1       2982          730     3.688799\nPBMMC-1_AAAGCAACATCAGTCA-1    PBMMC-1      22284         3108     3.181655\n                           percent.ribo percent.globin nCount_SCT nFeature_SCT\nPBMMC-1_AAACCTGCAGACGCAA-1     28.65473      0.1665973       3574          886\nPBMMC-1_AAACCTGTCATCACCC-1     55.03964      0.1981880       3908          746\nPBMMC-1_AAAGATGCATAAAGGT-1     30.43807      0.3776435       3964         1192\nPBMMC-1_AAAGCAAAGCAGCGTA-1     55.02942      0.3642477       3883          873\nPBMMC-1_AAAGCAACAATAACGA-1     54.49363      0.1006036       3795          711\nPBMMC-1_AAAGCAACATCAGTCA-1     23.40693     36.9682283       3979          962\n                           RNA_snn_res.0.1 RNA_snn_res.0.2 RNA_snn_res.0.3\nPBMMC-1_AAACCTGCAGACGCAA-1               5               7               7\nPBMMC-1_AAACCTGTCATCACCC-1               0               0               0\nPBMMC-1_AAAGATGCATAAAGGT-1               2               3               3\nPBMMC-1_AAAGCAAAGCAGCGTA-1               0               0               0\nPBMMC-1_AAAGCAACAATAACGA-1               0               0               0\nPBMMC-1_AAAGCAACATCAGTCA-1               4               2               2\n                           RNA_snn_res.0.4 RNA_snn_res.0.5 RNA_snn_res.0.6\nPBMMC-1_AAACCTGCAGACGCAA-1               7               7               9\nPBMMC-1_AAACCTGTCATCACCC-1               0               0               0\nPBMMC-1_AAAGATGCATAAAGGT-1               2               2               3\nPBMMC-1_AAAGCAAAGCAGCGTA-1               0               0               0\nPBMMC-1_AAAGCAACAATAACGA-1               0               0               0\nPBMMC-1_AAAGCAACATCAGTCA-1               5               5               5\n                           RNA_snn_res.0.7 RNA_snn_res.0.8 seurat_clusters\nPBMMC-1_AAACCTGCAGACGCAA-1               9               8               8\nPBMMC-1_AAACCTGTCATCACCC-1               0               0               0\nPBMMC-1_AAAGATGCATAAAGGT-1               2               2               2\nPBMMC-1_AAAGCAAAGCAGCGTA-1               0               0               0\nPBMMC-1_AAAGCAACAATAACGA-1               0               0               0\nPBMMC-1_AAAGCAACATCAGTCA-1               5               5               5\n\n\nTo view how clusters sub-divide at increasing resolution:\n\nlibrary(clustree)\n\nLoading required package: ggraph\n\n\nLoading required package: ggplot2\n\nclustree::clustree(seu@meta.data[,grep(\"RNA_snn_res\", colnames(seu@meta.data))],\n                   prefix = \"RNA_snn_res.\")\n\n\n\n\n\n\n\nYou can view the UMAP coloring each cell according to a cluster id like this:\n\nSeurat::DimPlot(seu, group.by = \"RNA_snn_res.0.1\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nVisualise clustering based on a few more resolutions. Taking the clustering and the UMAP plots into account what do you consider as a good resolution to perform the clustering?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nOf course, there is no ‘optimal’ resolution, but based on resolution of 0.3, the tree stays relatively stable for a few resolution steps, and it seems that clustering fits the UMAP well:\n\nSeurat::DimPlot(seu, group.by = \"RNA_snn_res.0.3\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nWhen do the number of neighbors need to be changed? How does changing the method of clustering in FindClusters affect the output? Which parameter should be changed?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nAs FindClusters is an unsupervised clustering method on the PCA data and UMAP is a good summary of the PCA dimension selected, clusters and UMAP plot should go along. If one has reasons to change the number of neighbors in the UMAP function, here the same parameter should be adapted.\nThe method can be changed with algorithm = 2,3 or 4\n\n\n\n\nsaveRDS(seu, \"day2/seu_day2-4.rds\")"
  },
  {
    "objectID": "day2/day2-2_dimensionality_reduction.html",
    "href": "day2/day2-2_dimensionality_reduction.html",
    "title": "Dimensionality reduction",
    "section": "",
    "text": "Download the presentation \n\n Download the presentation from the video \n\nMaking sense of PCA\n\nUnderstanding t-SNE\n\n\nt-SNE explained by Josh Starmer\nUnderstanding UMAP\n\n\nVideo by one of the UMAP authors\nMore info on UMAP parameters"
  },
  {
    "objectID": "day2/day2-2_dimensionality_reduction.html#material",
    "href": "day2/day2-2_dimensionality_reduction.html#material",
    "title": "Dimensionality reduction",
    "section": "",
    "text": "Download the presentation \n\n Download the presentation from the video \n\nMaking sense of PCA\n\nUnderstanding t-SNE\n\n\nt-SNE explained by Josh Starmer\nUnderstanding UMAP\n\n\nVideo by one of the UMAP authors\nMore info on UMAP parameters"
  },
  {
    "objectID": "day2/day2-2_dimensionality_reduction.html#exercises",
    "href": "day2/day2-2_dimensionality_reduction.html#exercises",
    "title": "Dimensionality reduction",
    "section": "Exercises",
    "text": "Exercises\nLoad the seu dataset you have created yesterday:\n\nseu &lt;- readRDS(\"day2/seu_day2-1.rds\")\n\nAnd load the following packages:\n\nlibrary(Seurat)\n\nOnce the data is normalized, scaled and variable features have been identified, we can start to reduce the dimensionality of the data. For the PCA, by default, only the previously determined variable features are used as input, but can be defined using features argument if you wish to specify a vector of genes. The PCA will only be run on the variable features, that you can check with VariableFeatures(seu).\n\nseu &lt;- Seurat::RunPCA(seu)\n\nTo view the PCA plot:\n\nSeurat::DimPlot(seu, reduction = \"pca\")\n\n\n\n\n\n\n\nWe can colour the PCA plot according to any factor that is present in @meta.data, or for any gene. For example we can take the column percent.globin:\n\nSeurat::FeaturePlot(seu, reduction = \"pca\", features = \"percent.globin\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that we used a different plotting function here: FeaturePlot. The difference between DimPlot and FeaturePlot is that the first allows you to color the points in the plot according to a grouping variable (e.g. sample) while the latter allows you to color the points according to a continuous variable (e.g. gene expression).\n\n\n\n\n\n\n\n\nExercise\n\n\n\nGenerate a PCA plot where color is according to counts of a gene (i.e. gene expression). For example, you can take HBA1 (alpha subunit of hemoglobin), or one of the most variable genes (e.g. IGKC).\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nGenerating a PCA plot coloured according to gene expression (here HBA1):\n\nSeurat::FeaturePlot(seu, reduction = \"pca\", features = \"HBA1\")\n\n\n\n\n\n\n\n\n\n\nWe can generate heatmaps according to their principal component scores calculated in the rotation matrix:\n\nSeurat::DimHeatmap(seu, dims = 1:12, cells = 500, balanced = TRUE)\n\n\n\n\n\n\n\nThe elbowplot can help you in determining how many PCs to use for downstream analysis such as UMAP:\n\nSeurat::ElbowPlot(seu, ndims = 40) +\n  ggplot2::geom_vline(xintercept = 25, linetype = \"dashed\", color = \"red\", linewidth = 1)\n\n\n\n\n\n\n\nThe elbow plot ranks principle components based on the percentage of variance explained by each one. Where we observe an “elbow” or flattening curve, the majority of true signal is captured by this number of PCs, eg around 25 PCs for the seu dataset.\nIncluding too many PCs usually does not affect much the result, while including too few PCs can affect the results very much.\nUMAP: The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space.\n\nseu &lt;- Seurat::RunUMAP(seu, dims = 1:25)\n\nTo view the UMAP plot:\n\nSeurat::DimPlot(seu, reduction = \"umap\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nTry to change:\nA. Color the dots in the UMAP according to a variable (e.g. percent.globin or HBA1). Any idea where the erythrocytes probably are in the UMAP?\nB. The number of neighbors used for the calculation of the UMAP. Which is the parameter to change and how did it affect the output. What is the default ? In which situation would you lower/increase this ?\nC. The number of dims to extremes dims = 1:5 or dims = 1:50 how did it affect the output ? In your opinion better few PCAs too much or too few ? Why does dims = 1:100 not work? When would more precision be needed?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nAnswer A\n\nSeurat::FeaturePlot(seu, features = c(\"HBA1\",\n                                      \"percent.globin\",\n                                      \"IGKC\",\n                                      \"percent.mito\"))\n\n\n\n\n\n\n\nThe erythrocytes are probably in the cluster with a higher percentage of globin expression.\nAnswer B\n\nseu &lt;- Seurat::RunUMAP(seu, dims = 1:25, n.neighbors = 5)\n\n\nSeurat::DimPlot(seu, reduction = \"umap\")\n\n\n\n\n\n\n\nThe default number of neighbours is 30. It can be of interest to change the number of neighbors if one has subset the data (for instance in the situation where you would only consider the t-cells in your data set), then maybe the number of neighbors in a cluster would anyway be most of the time lower than 30 then 30 is too much. In the other extreme where your dataset is extremely big an increase in the number of neighbors can be considered.\nAnswer C\n\nseu &lt;- Seurat::RunUMAP(seu, dims = 1:5)\n\n\nSeurat::DimPlot(seu, reduction = \"umap\")\n\n\n\n\n\n\n\n\nseu &lt;- Seurat::RunUMAP(seu, dims = 1:50) \n\n\nSeurat::DimPlot(seu, reduction = \"umap\")\n\n\n\n\n\n\n\nTaking dims = 1:100 does not work as in the step RunPCA by default only 50pcs are calculated, so the maximum that we can consider in further steps are 50, if more precision makes sense, for instance, if the genes that is of interest for your study is not present when the RunPCA was calculated, then an increase in the number of components calculated at start might be interesting tobe considered. Taking too few PCs we have a « blob » everything looks connected. Too many PCs tends to separate everything. Personally it is more interesting for me too have maybe 2 clusters separated of epithelial cells that I then group for further downstream analysis rather than having very distinct cells being clustered together. So I would rather take the « elbow » of the elbow plot a bit further to the right.\n\n\n\n\nAfter having done these exercises, change the UMAP back to a UMAP based on the first 25 PCs, in order to replicate the exercises in the following chapters. Do this by:\n\nseu &lt;- Seurat::RunUMAP(seu, dims = 1:25)"
  },
  {
    "objectID": "day1/day1-2_analysis_tools_qc.html",
    "href": "day1/day1-2_analysis_tools_qc.html",
    "title": "Analysis tools and QC",
    "section": "",
    "text": "Learning outcomes\n\n\n\nAfter having completed this chapter you will be able to:\n\nLoad single cell data into R\nExplain the basic structure of a Seurat object and extract count data and metadata\nCalculate and visualize quality measures based on:\n\nmitochondrial genes\nribosomal genes\nhemoglobin genes\nrelative gene expression\n\n\nInterpret the above quality measures per cell.\nPerform cell filtering based on quality thresholds"
  },
  {
    "objectID": "day1/day1-2_analysis_tools_qc.html#material",
    "href": "day1/day1-2_analysis_tools_qc.html#material",
    "title": "Analysis tools and QC",
    "section": "Material",
    "text": "Material\n Download the presentation"
  },
  {
    "objectID": "day1/day1-2_analysis_tools_qc.html#exercises",
    "href": "day1/day1-2_analysis_tools_qc.html#exercises",
    "title": "Analysis tools and QC",
    "section": "Exercises",
    "text": "Exercises\nLoading scRNAseq data\nThe next step after the generation of the count matrices with cellranger count, is the data analysis. The R package Seurat is currently the most popular software to do this. To start working with Seurat you can load it into your environment like this:\n\nlibrary(Seurat)\n\n\n\n\n\n\n\nAlternative: Bioconductor\n\n\n\nAnother popular ecosystem for single-cell analysis in R is Bioconductor. It provides a collection of packages for the analysis of high-throughput genomic data. The core data structure for single-cell data in Bioconductor is the SingleCellExperiment object, which is conceptually similar to the Seurat object. While this course focuses on Seurat, many of the same principles and workflows can be applied using Bioconductor packages.\n\n\n\n\n\n\n\n\nTip: make an R script\n\n\n\nYou could type and copy-paste the commands of these exercises directly in the console. However, that makes it hard to track what you have done. In addition, it can be nice to add comments to your code, so you can read back why you have made certain choices. In order to do that, do not write commands in the console, but write them in a script, and send them to the console with ^ Ctrl + ⏎ Enter (Windows) or ⌘ Command + ⏎ Enter (MacOS).\n\n\nFirst, we will load a file specifying the different samples, and create an object specifying the location of the count data:\n\nsample_info &lt;- read.csv(\"course_data/sample_info_course.csv\")\ndatadirs &lt;- file.path(\"course_data\", \"count_matrices\", sample_info$SampleName,\n                      \"outs\", \"filtered_feature_bc_matrix\")\nnames(datadirs) &lt;- gsub(\"_\", \"-\", sample_info$SampleName)\ndatadirs &lt;- datadirs[1:3]\n\nThe object datadirs is a named vector specifying the paths of the count directories for each sample:\n\n\n                                                             PBMMC-1 \n\"course_data/count_matrices/PBMMC_1/outs/filtered_feature_bc_matrix\" \n                                                             PBMMC-2 \n\"course_data/count_matrices/PBMMC_2/outs/filtered_feature_bc_matrix\" \n                                                             PBMMC-3 \n\"course_data/count_matrices/PBMMC_3/outs/filtered_feature_bc_matrix\" \n\n\nTo run through a typical Seurat analysis, we will use the files that are in the directory data/filtered_feature_bc_matrix. This directory is part of the output generated by cellranger. To load this data into R and generate a sparse matrix, run the following command:\n\nsparse_matrix &lt;- Seurat::Read10X(data.dir = datadirs)\n\nThis imports a raw count matrix. Have a look at the counts of the first 30 cells of three genes by running:\n\nsparse_matrix[c(\"PECAM1\", \"CD8A\", \"TSPAN1\"), 1:30]\n\n3 x 30 sparse Matrix of class \"dgCMatrix\"\n\n\n  [[ suppressing 30 column names 'PBMMC-1_AAACCTGCAGACGCAA-1', 'PBMMC-1_AAACCTGTCATCACCC-1', 'PBMMC-1_AAAGATGCATAAAGGT-1' ... ]]\n\n\n                                                                  \nPECAM1 . . . . . . . 1 . . . . 1 . . 1 . . . . . . . 1 . . . . . .\nCD8A   . 1 . . 1 . . . . . . . . . . . . . . . . . . . . . . . . .\nTSPAN1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n\nYou will see many dots (zeros) and a few integers representing the counts per gene per cell.\nTo generate a Seurat object, we will run CreateSeuratObject. Note that while creating the object, we already do some mild filtering; we only import genes that are expressed in at least 3 cells, and we only import cells that have at least 100 different genes expressed:\n\nseu &lt;- Seurat::CreateSeuratObject(counts = sparse_matrix,\n                                  project = \"pbmmc\",\n                                  min.cells = 3,\n                                  min.features = 100)\n\nWarning: Feature names cannot have underscores ('_'), replacing with dashes\n('-')\n\n\n\n\n\n\n\n\nFunction notation with ::\n\n\n\nHere, we define the function together with its associated package. We do that by the syntax package::function. Of course, you can also call library(package), and only type the function name. Since we use many different packages in this course, it can be confusing which function comes from which package. Therefore, we chose to always associate the package with the called function.\n\n\n\n\n\n\n\n\nExercise\n\n\n\ncheck what’s in the seu object, by typing seu in the R console. How many features are in there? And how many cells?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nTyping seu should return:\n\n\nAn object of class Seurat \n18673 features across 6946 samples within 1 assay \nActive assay: RNA (18673 features, 0 variable features)\n 1 layer present: counts\n\n\nThis means that we have 18673 genes (features) in there, and 6946 cells (samples)\n\n\n\nThe Seurat object\nThe seu object we have created has the class Seurat. The object contains multi-level slots and lists. Each Seurat object contains exactly the same slots that are specified in the image below (get slot descriptions by typing ?SeuratObject::Seurat). You can get the information inside a slot with @, in the same way as you would use the $ for lists (e.g. seu@meta.data will return the a data frame with information on each cell). Slots can be filled with other R objects, like lists, vectors, data frames or any other class. Here’s an overview of all slots that are in a Seurat object:\n\nIn addition to the original count table, the Seurat object can therefore store a lot of information that is generated during your analysis, like results of a normalization (@assays$RNA@data) a PCA or UMAP (@reductions) and the clustering (@graphs). It also tracks all the commands that have been used to generate the object in its current state (@commands). Therefore, while going through the analysis steps, the same object gets more and more of its slots filled. Because most Seurat functions return the input object + adjusted slots, we can use this syntax:\nseurat_object &lt;- Seurat::function(seurat_object)\nSo, the function takes an object as input and we assign it to an object with the same name. Meaning that we overwrite the object used as input. This is fine in many cases, because Seurat adds information to the input object, and returns is. We will use this syntax for the first time at Normalization and scaling.\n\n\n\n\n\n\nGetting specific information out of the Seurat object\n\n\n\nIn order to get specific data you can use the @ and $ symbols to browse through the objects. However, Seurat comes with a lot of convenience functions, that are easier to use. So, e.g. to get the raw count matrix, you could type seu@assays$RNA@layers$counts, however, this is equivalent to GetAssayData(object = seu, layer = \"counts\"). More information on these convenience functions here.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nA. Have a look at the seu object by running View(seu). What is in there? What is stored in @active.ident?\nB. Have a look at the data.frame stored at seu@meta.data what kind of information is in there?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nAnswer A\nThere are many slots as described in the above figure. The slot @active.ident contains data specifying the samples, e.g. table(seu@active.ident) returns:\nPBMMC-1 PBMMC-2 PBMMC-3 \n1612    3105    2229 \nWhich are the number of cells per sample.\nAnswer B\nRunning head(seu@meta.data) returns:\n                            orig.ident nCount_RNA nFeature_RNA\nPBMMC-1_AAACCTGCAGACGCAA-1    PBMMC-1       2401          909\nPBMMC-1_AAACCTGTCATCACCC-1    PBMMC-1       3532          760\nPBMMC-1_AAAGATGCATAAAGGT-1    PBMMC-1       3972         1215\nPBMMC-1_AAAGCAAAGCAGCGTA-1    PBMMC-1       3569          894\nPBMMC-1_AAAGCAACAATAACGA-1    PBMMC-1       2982          730\nPBMMC-1_AAAGCAACATCAGTCA-1    PBMMC-1      22284         3108\nGiving you the names of three columns and a row for each cell:\n\n\norig_ident: the original identity (origin) of a cell.\n\nnCount_RNA: the number of reads assigned to a cell.\n\nnFeature_RNA: the number of expressed features (genes) per cell.\n\n\n\n\nLuckily, usually you do not have to dive into this structure to retrieve information. For example, information in the slot @meta.data can be retrieved and set by using $ or [[]].\n\n\n\n\n\n\nNote\n\n\n\nThere is a subtle difference here between $ and [[]]. While $ returns a vector of the column in @meta.data, [[]] returns a data.frame.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nGenerate a histogram of the column nCount_RNA at seu@meta.data, with the base function hist.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nhist(seu$nCount_RNA)\n\n\n\n\n\n\n\nor\n\nhist(seu@meta.data$nCount_RNA)\n\n\n\n\n\n\n\n\n\n\nThere are also built-in functions to plot data from Seurat object, for example FeatureScatter. This function enables you easily draw a scatterplot from a Seurat object:\n\nSeurat::FeatureScatter(seu, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\")\n\n\n\n\n\n\n\nYou can find a nice overview of such functions here.\nVisualizing QC per cell and gene\nWhile generating the Seurat object, there were already some quality measures calculated for each cell, namely the total UMI counts per cell (nCount_RNA) and the total number of detected features per cell (nFeature_RNA). We can plot those in a violin plot and evaluate their distribution per sample:\n\nSeurat::VlnPlot(seu, features = c(\"nCount_RNA\",\n                                  \"nFeature_RNA\"))\n\nWarning: Default search for \"data\" layer in \"RNA\" assay yielded no results;\nutilizing \"counts\" layer instead.\n\n\n\n\n\n\n\n\nYou can see that there is quite a wide range for both. A cell with low number of detected features or counts might not give you a lot of information, while a high number of detected features/counts might point to doublets.\nSingle cells have often undergone sampling and/or dissociation and/or sorting. Therefore, there are often cells and genes in your dataset that cause variation due to technical reasons. In the following steps, we will visualize those and make decisions on whether or not to remove cells or genes with extreme values.\nWe will start with calculating the percentage of counts coming from transcript types:\n\n\nMitochondrial genes: If a cell membrane is damaged, it looses free RNA quicker compared to mitochondrial RNA, because the latter is part of the mitochondrion. A high relative amount of mitochondrial counts can therefore point to damaged cells (Lun et al. 2016).\n\nRibosomal genes: Are not rRNA (ribosomal RNA) but is mRNA that code for ribosomal proteins. They do not point to specific issues, but it can be good to have a look at their relative abundance. They can have biological relevance (e.g. Caron et al. 2020).\n\nHemoglobin genes: these transcripts are very abundant in erythrocytes. Depending on your application, you can expect ‘contamination’ of erythrocytes and select against it.\n\nIn order to have an idea about the relative counts of these type of genes in our dataset, we can calculate their expression as relative counts in each cell. We do that by selecting genes based on patterns (e.g. ^MT- matches with all gene names starting with MT, i.e. mitochondrial genes):\n\n# mitochondrial genes\nseu &lt;- Seurat::PercentageFeatureSet(seu, \n                                    pattern = \"^MT-\", \n                                    col.name = \"percent.mito\")\n\n# ribosomal genes\nseu &lt;- Seurat::PercentageFeatureSet(seu, \n                                    pattern = \"^RP[SL]\",\n                                    col.name = \"percent.ribo\")\n\n# hemoglobin genes (but not HBP)\nseu &lt;- Seurat::PercentageFeatureSet(seu,\n                                    pattern = \"^HB[^(P)]\",\n                                    col.name = \"percent.globin\")\n\n\n\n\n\n\n\nExercise\n\n\n\nRun the commands and check out the metadata data frame at seu@meta.data. What has changed?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nIf we type head(seu@meta.data) it returns:\n\n\n                           orig.ident nCount_RNA nFeature_RNA percent.mito\nPBMMC-1_AAACCTGCAGACGCAA-1    PBMMC-1       2401          909     2.540608\nPBMMC-1_AAACCTGTCATCACCC-1    PBMMC-1       3532          760     5.181200\nPBMMC-1_AAAGATGCATAAAGGT-1    PBMMC-1       3972         1215     4.934542\nPBMMC-1_AAAGCAAAGCAGCGTA-1    PBMMC-1       3569          894     3.250210\nPBMMC-1_AAAGCAACAATAACGA-1    PBMMC-1       2982          730     3.688799\nPBMMC-1_AAAGCAACATCAGTCA-1    PBMMC-1      22284         3108     3.181655\n                           percent.ribo percent.globin\nPBMMC-1_AAACCTGCAGACGCAA-1     28.65473      0.1665973\nPBMMC-1_AAACCTGTCATCACCC-1     55.03964      0.1981880\nPBMMC-1_AAAGATGCATAAAGGT-1     30.43807      0.3776435\nPBMMC-1_AAAGCAAAGCAGCGTA-1     55.02942      0.3642477\nPBMMC-1_AAAGCAACAATAACGA-1     54.49363      0.1006036\nPBMMC-1_AAAGCAACATCAGTCA-1     23.40693     36.9682283\n\n\nSo, the function PercentageFeatureSet adds a column to meta.data, specifying the percentage of counts for the specified gene sets.\n\n\n\nNow we can plot the distribution of these percentages in a violin plot:\n\nSeurat::VlnPlot(seu, features = c(\"percent.mito\",\n                                  \"percent.ribo\",\n                                  \"percent.globin\"))\n\nWarning: Default search for \"data\" layer in \"RNA\" assay yielded no results;\nutilizing \"counts\" layer instead.\n\n\n\n\n\n\n\n\nYou can see that PBMMC-2 is quite different from the two others, it has a group of cells with very low ribosomal counts and one with very high globin counts. Maybe these two percentages are negatively correlated? Let’s have a look, by plotting the two percentages against each other:\n\nSeurat::FeatureScatter(seu, \n                       feature1 = \"percent.globin\", \n                       feature2 = \"percent.ribo\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nAre they correlated? What kind of cells might have a high abundance of hemoglobin transcripts and low ribosomal transcripts?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nYes there is a negative correlation. Erythrocytes (red blood cells) have a high abundance of hemoglobin transcripts and low abundance of ribosomal transcripts. These are most likely erythroid cells, i.e. the cells predecessing erythrocytes in the bone marrow.\n\n\n\nWe can also evaluate the relative expression of other genes in our dataset, for example, the ones that are most highly expressed. Some very highly expressed genes might point to a technical cause, and we might consider to remove them. Below you will find a simple function to generate a boxplot of relative counts per gene per cell. Load it into your environment and run it on our seu object:\n\nlibrary(ggplot2)\nlibrary(Matrix)\nlibrary(Seurat)\n\nmost_expressed_boxplot &lt;- function(object, ngenes = 20){\n  \n  # matrix of raw counts\n  cts &lt;- Seurat::GetAssayData(object, assay = \"RNA\", layer = \"counts\")\n  \n  # get percentage/cell\n  cts &lt;- t(cts)/colSums(cts)*100\n  medians &lt;- SparseArray::colMedians(cts)\n  \n  # get top n genes\n  most_expressed &lt;- order(medians, decreasing = T)[ngenes:1]\n  most_exp_matrix &lt;- as.matrix((cts[,most_expressed]))\n  \n  # prepare for plotting\n  most_exp_df &lt;- stack(as.data.frame(most_exp_matrix))\n  colnames(most_exp_df) &lt;- c(\"perc_total\", \"gene\")\n  \n  # boxplot with ggplot2\n  boxplot &lt;- ggplot(most_exp_df, aes(x=gene, y=perc_total)) +\n    geom_boxplot() +\n    coord_flip()\n  return(boxplot)\n}\n\nmost_expressed_boxplot(seu, 20)\n\n\n\n\n\n\n\nAs for most 10X based poly-A enriched single cell datasets, we find a relatively high expression of MALAT1. Many researchers choose to remove it, but it can have biological relevance (e.g. Shaat et al. 2021).\nCell filtering\nBased on the QC process we went through we can come to the following conclusions:\n\nThere are no cells with very high mitochondrial gene counts.\nThere are some cells with a hemoglobin and low ribosomal counts, and these are probably erythrocytes.\nThere are some cells with a very low and very high number of features. These might point to non-informative cells and doublets respectively.\nThe ‘usual suspect’ MALAT1 sometimes makes up a large part of the counts per cell. As we do not see any other suggestions of dying/stressed cells, we leave it in.\n\nIn this case, a sensible decision would be to do mild filtering on the number of features per cell and mitochondrial counts. We can leave the possible erythrocytes in for now, and see where they end up later during the dimensionality reduction.\nIn the M&M of the publication, the authors describe that they have used a threshold of &lt; 8% mitochondrial counts and &gt; 200 features per cell. To filter against possible doublets, here, we also filter out cells with &gt; 5000 detected features/cell. Filtering Seurat objects can be done with the subset method for class SeuratObject:\n\nseu &lt;- subset(seu, subset = nFeature_RNA &gt; 200 & \n                nFeature_RNA &lt; 5000 &\n                percent.mito &lt; 8)\n\nTo evaluate this did the trick we can visualize those parameters again in a violin plot:\n\nSeurat::VlnPlot(seu, features = c(\"nFeature_RNA\",\n                                  \"percent.mito\"))\n\nWarning: Default search for \"data\" layer in \"RNA\" assay yielded no results;\nutilizing \"counts\" layer instead.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCommon Pitfalls and Best Practices in QC\n\n\n\nQuality control is a critical step in single-cell RNA sequencing analysis. Here are some common pitfalls and best practices to keep in mind:\n\n\nDon’t rely on default thresholds: While general guidelines exist (e.g., mitochondrial percentage &lt; 10%), optimal thresholds can vary significantly between experiments, tissues, and protocols. Always inspect your data visually (e.g., with violin plots and scatter plots) to determine appropriate cutoffs.\n\nConsider biological context: High mitochondrial content might indicate dying cells in some contexts, but could be biologically meaningful in others (e.g., highly metabolic cells). Similarly, high gene counts could indicate doublets or genuinely large, transcriptionally active cells.\n\nDoublet detection: Manual filtering based on high gene/UMI counts is a crude method for doublet removal. Consider using dedicated doublet detection tools (e.g., DoubletFinder, scDblFinder) for more robust identification and removal of cell doublets.\n\nBatch effects: If your experiment involves multiple batches, ensure that your QC metrics are consistent across batches. Significant differences in QC metrics between batches might indicate technical issues that need to be addressed before downstream analysis.\n\nIterative QC: QC is often an iterative process. Initial filtering might reveal new patterns or issues that require further investigation and adjustment of thresholds.\n\nDocument your decisions: Always clearly document the QC metrics used, the thresholds applied, and the rationale behind your decisions. This ensures reproducibility and transparency of your analysis.\n\n\n\n\nsaveRDS(seu, \"day1/seu_day1-2.rds\")"
  },
  {
    "objectID": "day1/day1-1_setup.html",
    "href": "day1/day1-1_setup.html",
    "title": "Setup",
    "section": "",
    "text": "Download the presentation"
  },
  {
    "objectID": "day1/day1-1_setup.html#material",
    "href": "day1/day1-1_setup.html#material",
    "title": "Setup",
    "section": "",
    "text": "Download the presentation"
  },
  {
    "objectID": "day1/day1-1_setup.html#exercises",
    "href": "day1/day1-1_setup.html#exercises",
    "title": "Setup",
    "section": "Exercises",
    "text": "Exercises\nLogin and set up\nChoose one of the following:\n\n\nEnrolled: if you are enrolled in a course with a teacher\n\nOwn installation: if you want to install packages on your own local Rstudio installation\n\nDocker: if you want to use the docker image locally\n\nrenkulab.io if you want to easily deploy the environment outside the course\n\n\n\nEnrolled\nOwn installation\nDocker\nrenkulab.io\n\n\n\nLog in to Rstudio server with the provided link, username and password.\n\n\nInstall the required packages using renv\n\ninstall.packages(\"renv\")\n\nrenv::restore(lockfile = \"https://raw.githubusercontent.com/sib-swiss/single-cell-r-training/refs/heads/master/renv.lock\")\n\n\n\nWith docker, you can use exactly the same environment as we use in the enrolled course, but than running locally.\nIn the video below there’s a short tutorial on how to set up a docker container for this course. Note that you will need administrator rights, and that if you are using Windows, you need the latest version of Windows 10.\n\nThe command to run the environment required for this course looks like this (in a terminal):\n\n\n\n\n\n\nModify the script\n\n\n\nThe home directory within the container is mounted to your current directory ($PWD), if you want to change this behaviour, modify the path after -v to the working directory on your computer before running it.\n\n\n\ndocker run \\\n--rm \\\n-p 8787:8787 \\\n-e PASSWORD=test \\\n-v $PWD:/home/rstudio \\\nsibswiss/training-singlecell-rstudio:2025.7\n\nIf this command has run successfully, approach Rstudio server like this:\nhttp://localhost:8787\nCopy this URL into your browser. If you used the snippet above, the credentials will be:\n\n\nUsername: rstudio\n\n\nPassword: test\n\n\nGreat! Now you will be able to use Rstudio with all required installations.\n\n\n\n\n\n\nAbout the options\n\n\n\nThe option -v mounts a local directory in your computer to the directory /home/rstudio in the docker container (‘rstudio’ is the default user for Rstudio containers). In that way, you have files available both in the container and on your computer. Use this directory on your computer. Change the first path to a path on your computer that you want to use as a working directory.\nThe part sibswiss/training-singlecell-rstudio:2025.7 is the image we are going to load into the container. The image contains all the information about software and dependencies needed for this course. When you run this command for the first time it will download the image. Once it’s on your computer, it will start immediately.\n\n\n\n\nTo simply run the environment, you can use renku. You can find the repository (including the image) here: https://renkulab.io/projects/geert.vangeest/single-cell-training/.\n\n\n\nCreate a project\nNow that you have access to an environment with the required installations, we will set up a project in a new directory. On the top right choose the button Project (None) and select New Project…\n\nContinue by choosing New Directory\n\nAs project type select New Project\n\nFinally, type in the project name. This should be single_cell_course. Finish by clicking Create Project.\n\nNow that we have setup a project and a project directory (it is in /home/rstudio/single_cell_course), we can download the data that is required for this course. We will use the built-in terminal of Rstudio. To do this, select the Terminal tab:\n\nDownloading the course data\nTo download and extract the dataset, copy-paste these commands inside the terminal tab:\n\nwget https://single-cell-transcriptomics.s3.eu-central-1.amazonaws.com/course_data.tar.gz\ntar -xvf course_data.tar.gz\nrm course_data.tar.gz\n\n\n\n\n\n\n\nIf on Windows\n\n\n\nIf you’re using Windows, you can directly open the link in your browser, and downloading will start automatically. Unpack the tar.gz file in the directory where you want to work in during the course.\n\n\nHave a look at the data directory you have downloaded. It should contain the following:\ncourse_data\n├── count_matrices\n│   ├── ETV6-RUNX1_1\n│   │   └── outs\n│   │       └── filtered_feature_bc_matrix\n│   │           ├── barcodes.tsv.gz\n│   │           ├── features.tsv.gz\n│   │           └── matrix.mtx.gz\n│   ├── ETV6-RUNX1_2\n│   │   └── outs\n│   │       └── filtered_feature_bc_matrix\n│   │           ├── barcodes.tsv.gz\n│   │           ├── features.tsv.gz\n│   │           └── matrix.mtx.gz\n│   ├── ETV6-RUNX1_3\n│   │   └── outs\n│   │       └── filtered_feature_bc_matrix\n│   │           ├── barcodes.tsv.gz\n│   │           ├── features.tsv.gz\n│   │           └── matrix.mtx.gz\n│   ├── PBMMC_1\n│   │   └── outs\n│   │       └── filtered_feature_bc_matrix\n│   │           ├── barcodes.tsv.gz\n│   │           ├── features.tsv.gz\n│   │           └── matrix.mtx.gz\n│   ├── PBMMC_2\n│   │   └── outs\n│   │       └── filtered_feature_bc_matrix\n│   │           ├── barcodes.tsv.gz\n│   │           ├── features.tsv.gz\n│   │           └── matrix.mtx.gz\n│   └── PBMMC_3\n│       └── outs\n│           └── filtered_feature_bc_matrix\n│               ├── barcodes.tsv.gz\n│               ├── features.tsv.gz\n│               └── matrix.mtx.gz\n└── reads\n    ├── ETV6-RUNX1_1_S1_L001_I1_001.fastq.gz\n    ├── ETV6-RUNX1_1_S1_L001_R1_001.fastq.gz\n    └── ETV6-RUNX1_1_S1_L001_R2_001.fastq.gz\n\n20 directories, 21 files\nThis data comes from:\nCaron M, St-Onge P, Sontag T, Wang YC, Richer C, Ragoussis I, et al. Single-cell analysis of childhood leukemia reveals a link between developmental states and ribosomal protein expression as a source of intra-individual heterogeneity. Scientific Reports. 2020;10:1–12. Available from: http://dx.doi.org/10.1038/s41598-020-64929-x\nWe will use the reads to showcase the use of cellranger count. The directory contains only reads from chromosome 21 and 22 of one sample (ETV6-RUNX1_1). The count matrices are output of cellranger count, and we will use those for the other exercises in R."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "course_schedule.html",
    "href": "course_schedule.html",
    "title": "Course schedule",
    "section": "",
    "text": "Note\n\n\n\nApart from the starting time the time schedule is indicative. Because we can not plan a course by the minute, in practice the time points will deviate."
  },
  {
    "objectID": "course_schedule.html#day-1",
    "href": "course_schedule.html#day-1",
    "title": "Course schedule",
    "section": "Day 1",
    "text": "Day 1\n\n\n\nblock\nstart\nend\nsubject\nlecturer\n\n\n\n\nintroduction\n9:15 AM\n9:30 AM\nIntroduction\nMichal Kolar\n\n\nblock 1\n9:30 AM\n10:30 AM\nIntroduction scRNAseq\nMichal Kolar\n\n\n\n10:30 AM\n11:00 AM\nBREAK\n\n\n\nblock 2\n11:00 AM\n12:30 PM\n10X and Cellranger\nJan Kubovciak\n\n\n\n12:30 PM\n1:30 PM\nBREAK\n\n\n\nblock 3\n1:30 PM\n3:00 PM\nAnalysis tools and QC\nJan Kubovciak\n\n\n\n3:00 PM\n3:30 PM\nBREAK\n\n\n\nblock 4\n3:30 PM\n5:00 PM\nGroup work"
  },
  {
    "objectID": "course_schedule.html#day-2",
    "href": "course_schedule.html#day-2",
    "title": "Course schedule",
    "section": "Day 2",
    "text": "Day 2\n\n\n\nblock\nstart\nend\nsubject\nlecturer\n\n\n\n\nblock 1\n9:15 AM\n10:30 AM\nNormalization and scaling\nLucie Pfeiferova\n\n\n\n10:30 AM\n11:00 AM\nBREAK\n\n\n\nblock 2\n11:00 AM\n12:30 PM\nDimensionality reduction and Integration\nLucie Pfeiferova and Yusufcaglar Odabasi\n\n\n\n12:30 PM\n1:30 PM\nBREAK\n\n\n\nblock 3\n1:30 PM\n3:00 PM\nClustering\nYusufcaglar Odabasi\n\n\n\n3:00 PM\n3:30 PM\nBREAK\n\n\n\nblock 4\n3:30 PM\n5:00 PM\ngroup work"
  },
  {
    "objectID": "course_schedule.html#day-3",
    "href": "course_schedule.html#day-3",
    "title": "Course schedule",
    "section": "Day 3",
    "text": "Day 3\n\n\n\nblock\nstart\nend\nsubject\nlecturer\n\n\n\n\nblock 1\n9:15 AM\n10:30 AM\nCell annotation\nLucie Pfeiferova\n\n\n\n10:30 AM\n11:00 AM\nBREAK\n\n\n\nblock 2\n11:00 AM\n12:30 PM\nDifferential gene expression and Enrichment analysis\nJan Kubovciak\n\n\n\n12:30 PM\n1:30 PM\nBREAK\n\n\n\nblock 3\n1:30 PM\n3:00 PM\ngroup work\n\n\n\n\n3:00 PM\n3:30 PM\nBREAK\n\n\n\nblock 4\n3:30 PM\n5:00 PM\ngroup work + presentations\n\n\n\npost-course\n5:00 PM\n5:10 PM\nPost-course information\nMichal Kolar"
  },
  {
    "objectID": "day1/day1-1a_cellranger.html",
    "href": "day1/day1-1a_cellranger.html",
    "title": "Introduction & cellranger",
    "section": "",
    "text": "After having completed this chapter you will be able to:\n\nExplain what kind of information single cell RNA-seq can give you to answer a biological question\nDescribe essential considerations during the design of a single cell RNA-seq experiment\nDescribe the pros and cons of different single cell sequencing methods\nUse cellranger to:\n\nTo align reads and generate count tables\nPerform basic QC on alignments and counts"
  },
  {
    "objectID": "day1/day1-1a_cellranger.html#learning-outcomes",
    "href": "day1/day1-1a_cellranger.html#learning-outcomes",
    "title": "Introduction & cellranger",
    "section": "",
    "text": "After having completed this chapter you will be able to:\n\nExplain what kind of information single cell RNA-seq can give you to answer a biological question\nDescribe essential considerations during the design of a single cell RNA-seq experiment\nDescribe the pros and cons of different single cell sequencing methods\nUse cellranger to:\n\nTo align reads and generate count tables\nPerform basic QC on alignments and counts"
  },
  {
    "objectID": "day1/day1-1a_cellranger.html#material",
    "href": "day1/day1-1a_cellranger.html#material",
    "title": "Introduction & cellranger",
    "section": "Material",
    "text": "Material\nIntroduction to scRNA-seq and techniques:\n Download the presentation \n\n Download the presentation \n\n\nSingle cell introductory video on iBiology\nSeurat website\nPaper on experimental considerations\nPaper on experimental design\nSMART-seq3 protocol at protocols.io\ncellranger system requirements and installation\nReview by Tallulah Andrews\nPaper on correlation between mRNA and protein level in single cells"
  },
  {
    "objectID": "day1/day1-1a_cellranger.html#running-cellranger-count",
    "href": "day1/day1-1a_cellranger.html#running-cellranger-count",
    "title": "Introduction & cellranger",
    "section": "Running cellranger count",
    "text": "Running cellranger count\n\n\n\n\n\n\nIf working independently\n\n\n\nThe exercises below assume that you are enrolled in the course, and have access to the Rstudio server. These exercises are not essential to run for the rest of the course, so you can skip them. If you want to do them anyway, you can try to install cellranger locally (only on Linux or WSL). In addition, you will need to download the references. You can get it by with this code (choose your OS):\n\nLinux/MacOS/WSLWindows\n\n\nwget https://single-cell-transcriptomics.s3.eu-central-1.amazonaws.com/cellranger_index.tar.gz\ntar -xvf cellranger_index.tar.gz\nrm cellranger_index.tar.gz\n\n\nDownload using the link, and unpack in your working directory.\n\n\n\nThis will download and extract the index in the current directory. Specify the path to this reference in the exercises accordingly.\n\n\nHave a look in the directory course_data/reads and /data/cellranger_index. In the reads directory you will find reads on one sample: ETV6-RUNX1_1. In the analysis part of the course we will work with six samples, but due to time and computational limitations we will run cellranger count on one of the samples, and only reads originating from chromsome 21 and 22.\nThe input you need to run cellranger count are the sequence reads and a reference. Here, we have prepared a reference only with chromosome 21 and 22, but in ‘real life’ you would of course get the full reference genome of your species. The reference has a specific format. You can download precomputed human and mouse references from the 10X website. If your species of interest is not one of those, you will have to generate it yourself. For that, have a look here.\nTo be able to run cellranger in the compute environment, first run:\nexport PATH=/data/cellranger-9.0.1:$PATH\nHave a look at the documentation of cellranger count (scroll down to Command-line argument reference).\nYou can find the input files here:\n\nreads: /home/rstudio/single_cell_course/course_data/reads/ (from the downloaded tar package in your home directory)\npre-indexed reference: /data/cellranger_index\n\n\n\n\n\n\n\nExercise\n\n\n\nFill out the missing arguments (at FIXME) in the script below, and run it:\ncellranger count \\\n--id=FIXME \\\n--sample=FIXME \\\n--transcriptome=FIXME \\\n--fastqs=FIXME \\\n--localcores=4 \\\n--create-bam=true\n\n\n\n\n\n\n\n\nThis will take a while..\n\n\n\nOnce started, the process will need approximately 15 minutes to finish. Have a coffee and/or have a look at the other exercises.\n\n\n\n\n\n\n\n\nRunning a bash command with Rstudio\n\n\n\nYou can run a bash script or command using the terminal tab in Rstudio server:\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\ncellranger count \\\n--id=ETV6-RUNX1_1 \\\n--sample=ETV6-RUNX1_1 \\\n--transcriptome=/data/cellranger_index \\\n--fastqs=/home/rstudio/single_cell_course/course_data/reads \\\n--localcores=4 \\\n--create-bam=true\n\n\n\nHave a look out the output directory (i.e. ~/ETV6-RUNX1_1/outs). The analysis report (web_summary.html) is usually a good place to start.\n\n\n\n\n\n\nOpen html files in Rstudio server\n\n\n\nYou can use the file browser in the bottom right (tab “Files”) to open html files:\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nHave a good look inside web_summary.html. Anything that draws your attention? Is this report good enough to continue the analysis?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nNot really. First of all there is a warning: Fraction of RNA read bases with Q-score &gt;= 30 is low. This means that there is a low base quality of the reads. A low base quality gives results in more sequencing error and therefore possibly lower performance while mapping the reads to genes. However, a Q-score of 30 still represents 99.9% accuracy.\nWhat should worry us more is the number of reads per cell (363) and the sequencing saturation (7.9%). In most cases you should aim for 30.000 - 50.000 reads per cell (depending on the application). We therefore don’t have enough reads per cell. However, as you might remember, this was a subset of reads (1 million) mapped against chromosome 21 & 22, while the original dataset contains 210,987,037 reads. You can check out the original report at course_data/count_matrices/ETV6-RUNX1_1/outs/web_summary.html.\nFor more info on sequencing saturation, have a look here."
  },
  {
    "objectID": "day2/day2-1_normalization_scaling.html",
    "href": "day2/day2-1_normalization_scaling.html",
    "title": "Normalization and scaling",
    "section": "",
    "text": "Learning outcomes\n\n\n\nAfter having completed this chapter you will be able to:\n\nDescribe and perform standard procedures for normalization and scaling with the package Seurat\n\nSelect the most variable genes from a Seurat object for downstream analyses"
  },
  {
    "objectID": "day2/day2-1_normalization_scaling.html#material",
    "href": "day2/day2-1_normalization_scaling.html#material",
    "title": "Normalization and scaling",
    "section": "Material",
    "text": "Material"
  },
  {
    "objectID": "day2/day2-1_normalization_scaling.html#material-1",
    "href": "day2/day2-1_normalization_scaling.html#material-1",
    "title": "Normalization and scaling",
    "section": "Material",
    "text": "Material\n Download the presentation \n\n Download the presentation from the video \n\nSeurat vignette"
  },
  {
    "objectID": "day2/day2-1_normalization_scaling.html#exercises",
    "href": "day2/day2-1_normalization_scaling.html#exercises",
    "title": "Normalization and scaling",
    "section": "Exercises",
    "text": "Exercises\n\nlibrary(Seurat)\nlibrary(glmGamPoi)\nseu &lt;- readRDS(\"day1/seu_day1-2.rds\")\n\nNormalization\nAfter removing unwanted cells from the dataset, the next step is to normalize the data. By default, Seurat employs a global-scaling normalization method \"LogNormalize\" that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. This process is crucial to account for variations in sequencing depth across different cells, ensuring that differences in gene expression are biological rather than technical. The log-transformation helps to stabilize variance and makes the data more amenable to downstream statistical analyses, as it reduces the impact of highly expressed genes. Normalized values are stored in the “RNA” assay (as item of the @assay slot) of the seu object.\nThis is how you can call the function (don’t run it yet! Read the exercise first):\n\n# Don't run it yet! Read the exercise first\nseu &lt;- Seurat::NormalizeData(seu,\n                     normalization.method = \"LogNormalize\",\n                     scale.factor = 10000)\n\nNormalizing layer: counts\n\n\n\n\n\n\n\n\nExercise\n\n\n\nHave a look at the assay data before and after running NormalizeData(). Did it change?\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can extract assay data with the function Seurat::GetAssayData. By default, the slot data is used (inside the slot assay), containing normalized counts. Use Seurat::GetAssayData(seu, layer = \"counts\") to get the raw counts.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nYou can check out some assay data with:\n\nSeurat::GetAssayData(seu)[1:10,1:10]  \n\nReturning:\n\n\nBefore normalization\nAfter normalization\n\n\n\n\n\n10 x 10 sparse Matrix of class \"dgCMatrix\"\n\n\n  [[ suppressing 10 column names 'PBMMC-1_AAACCTGCAGACGCAA-1', 'PBMMC-1_AAACCTGTCATCACCC-1', 'PBMMC-1_AAAGATGCATAAAGGT-1' ... ]]\n\n\n                                 \nRP11-34P13.7  . . . . . . . . . .\nFO538757.3    . . . . . . . . . .\nFO538757.2    1 . . . . . 2 . . .\nAP006222.2    . . . . . . . . . .\nRP4-669L17.10 . . . . . . . . . .\nRP5-857K21.4  . . . . . . . . . .\nRP11-206L10.9 . . . . . . . . . .\nLINC00115     . . . . . . . . . .\nFAM41C        . . . . . . . . . .\nRP11-54O7.1   . . . . . . . . . .\n\n\n\n\n\n\nNormalizing layer: counts\n\n\n10 x 10 sparse Matrix of class \"dgCMatrix\"\n\n\n  [[ suppressing 10 column names 'PBMMC-1_AAACCTGCAGACGCAA-1', 'PBMMC-1_AAACCTGTCATCACCC-1', 'PBMMC-1_AAAGATGCATAAAGGT-1' ... ]]\n\n\n                                               \nRP11-34P13.7  .        . . . . . .        . . .\nFO538757.3    .        . . . . . .        . . .\nFO538757.2    1.641892 . . . . . 1.381104 . . .\nAP006222.2    .        . . . . . .        . . .\nRP4-669L17.10 .        . . . . . .        . . .\nRP5-857K21.4  .        . . . . . .        . . .\nRP11-206L10.9 .        . . . . . .        . . .\nLINC00115     .        . . . . . .        . . .\nFAM41C        .        . . . . . .        . . .\nRP11-54O7.1   .        . . . . . .        . . .\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUpdating seu\n\n\n\nAs you might have noticed, this function takes the object seu as input, and it returns it to an object named seu. We can do this because the output of such calculations are added to the object, without loosing information.\n\n\nVariable features\nWe next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). Focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets. The procedure in Seurat models the mean-variance relationship inherent in single-cell data, where highly expressed genes tend to have higher variance. By identifying genes with variance that is higher than expected given their mean expression, we can select features that are more likely to represent true biological variability rather than technical noise. This selection of variable features is crucial for dimensionality reduction techniques like PCA, as it focuses the analysis on the most informative genes.\n\nseu &lt;- Seurat::FindVariableFeatures(seu,\n                            selection.method = \"vst\",\n                            nfeatures = 2000)\n\nFinding variable features for layer counts\n\n\nLet’s have a look at the 10 most variable genes:\n\n# Identify the 10 most highly variable genes\ntop10 &lt;- head(Seurat::VariableFeatures(seu), 10)\ntop10\n\n [1] \"IGKC\"   \"HBG2\"   \"IGHG3\"  \"IGHG1\"  \"JCHAIN\" \"HBG1\"   \"IGHA1\"  \"IGHGP\" \n [9] \"IGLC2\"  \"IGLC3\" \n\n\nWe can plot them in a nicely labeled scatterplot:\n\nvf_plot &lt;- Seurat::VariableFeaturePlot(seu)\nSeurat::LabelPoints(plot = vf_plot,\n            points = top10, repel = TRUE)\n\nWhen using repel, set xnudge and ynudge to 0 for optimal results\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake sure the plotting window is large enough\n\n\n\nThe function LabelPoints will throw an error if the plotting window is to small. If you get an error, increase plotting window size in RStudio and try again.\n\n\nYou can see that most of the highly variables are antibody subunits (starting with IGH, IGL). Not very surprising since we look at bone marrow tissue. We can have a look later in which cells they are expressed.\nScaling\nNext, we apply scaling, a linear transformation that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The ScaleData() function\n\nshifts the expression of each gene, so that the mean expression across cells is 0\nscales the expression of each gene, so that the variance across cells is 1\n\nThis step is crucial because without it, highly expressed genes would disproportionately influence the principal components, masking the contributions of less abundant but potentially biologically significant genes. By scaling, we ensure that all genes contribute more equally to the downstream dimensionality reduction, allowing for a more accurate representation of biological variation. The results of this are stored in seu$RNA@scale.data\n\nseu &lt;- Seurat::ScaleData(seu)\n\nCentering and scaling data matrix\n\n\n\n\n\n\n\n\nThe use of Seurat::SCTransform\n\n\n\nThe functions NormalizeData, VariableFeatures and ScaleData can be replaced by the function SCTransform. The latter uses a more sophisticated way to perform the normalization and scaling, and is argued to perform better. However, it is slower, and a bit less transparent compared to using the three separate functions. Therefore, we chose not to use SCTransform for the exercises.\n\n\n\n\n\n\n\n\nBonus exercise\n\n\n\nRun SCTransform on the seu object. Where is the output stored?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nYou can run it like so:\n\nseu &lt;- Seurat::SCTransform(seu)\n\nAnd it will add an extra assay to the object. names(seu@assays) returns:\n\n\n[1] \"RNA\" \"SCT\"\n\n\nMeaning that a whole new assay was added (including the sparse matrices with counts, normalized data and scaled data).\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nRunning SCTransform will change @active.assay into SCT(in stead of RNA; check it with DefaultAssay(seu)). This assay is used as a default for following function calls. To change the active assay to RNA run:\n\nDefaultAssay(seu) &lt;- \"RNA\"\n\n\n\nSave the dataset and clear environment\nNow, save the dataset so you can use it tomorrow:\n\nsaveRDS(seu, \"day2/seu_day2-1.rds\")\n\nClear your environment:\n\nrm(list = ls())\ngc()\n.rs.restartR()"
  },
  {
    "objectID": "day2/day2-3_integration.html",
    "href": "day2/day2-3_integration.html",
    "title": "Integration",
    "section": "",
    "text": "Download the presentation \n\n Download the presentation from the video"
  },
  {
    "objectID": "day2/day2-3_integration.html#material",
    "href": "day2/day2-3_integration.html#material",
    "title": "Integration",
    "section": "",
    "text": "Download the presentation \n\n Download the presentation from the video"
  },
  {
    "objectID": "day2/day2-3_integration.html#exercises",
    "href": "day2/day2-3_integration.html#exercises",
    "title": "Integration",
    "section": "Exercises",
    "text": "Exercises\n\nlibrary(Seurat)\nseu &lt;- readRDS(\"day2/seu_day2-2.rds\")\n\nLet’s have a look at the UMAP again. Although cells of different samples are shared amongst ‘clusters’, you can still see seperation within the clusters:\n\nSeurat::DimPlot(seu, reduction = \"umap\")\n\n\n\n\n\n\n\nTo perform the integration, we split our object by sample, resulting into a set of layers within the RNA assay. The layers are integrated and stored in the reduction slot - in our case we call it integrated.cca. Then, we re-join the layers\n\nseu[[\"RNA\"]] &lt;- split(seu[[\"RNA\"]], f = seu$orig.ident)\n\nseu &lt;- Seurat::IntegrateLayers(object = seu, method = CCAIntegration,\n                       orig.reduction = \"pca\",\n                       new.reduction = \"integrated.cca\",\n                       verbose = FALSE)\n\n# re-join layers after integration\nseu[[\"RNA\"]] &lt;- JoinLayers(seu[[\"RNA\"]])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can then use this new integrated matrix for clustering and visualization. Now, we can re-run and visualize the results with UMAP.\n\n\n\n\n\n\nExercise\n\n\n\nCreate the UMAP again on the integrated.cca reduction (using the function RunUMAP - set the option reduction accordingly). After that, generate the UMAP plot. Did the integration perform well?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nPerforming the scaling, PCA and UMAP:\n\nseu &lt;- RunUMAP(seu, dims = 1:30, reduction = \"integrated.cca\")\n\nPlotting the UMAP:\n\nSeurat::DimPlot(seu, reduction = \"umap\")\n\n\n\n\n\n\n\n\n\n\nSave the dataset and clear environment\n\nsaveRDS(seu, \"day2/seu_day2-3.rds\")"
  },
  {
    "objectID": "day3/day3-1_cell_annotation.html",
    "href": "day3/day3-1_cell_annotation.html",
    "title": "Cell annotation",
    "section": "",
    "text": "Download the presentation \n\n Download the presentation from the video \n\nReview on automated cell annotation"
  },
  {
    "objectID": "day3/day3-1_cell_annotation.html#material",
    "href": "day3/day3-1_cell_annotation.html#material",
    "title": "Cell annotation",
    "section": "",
    "text": "Download the presentation \n\n Download the presentation from the video \n\nReview on automated cell annotation"
  },
  {
    "objectID": "day3/day3-1_cell_annotation.html#exercises",
    "href": "day3/day3-1_cell_annotation.html#exercises",
    "title": "Cell annotation",
    "section": "Exercises",
    "text": "Exercises\n\nseu &lt;- readRDS(\"day2/seu_day2-4.rds\")\nlibrary(Seurat)\n\nLoad the following packages:\n\nlibrary(celldex)\nlibrary(SingleR)\n\nIn the last exercise we saw that probably clustering at a resolution of 0.3 gave the most sensible results. Let’s therefore set the default identity of each cell based on this clustering:\n\nseu &lt;- Seurat::SetIdent(seu, value = seu$RNA_snn_res.0.3)\n\n\n\n\n\n\n\nNote\n\n\n\nFrom now on, grouping (e.g. for plotting) is done by the active identity (set at @active.ident) by default.\n\n\nDuring cell annotation we will use the original count data (not the integrated data):\n\nDefaultAssay(seu) &lt;- \"RNA\"\n\nBased on the UMAP we have generated, we can visualize expression for a gene in each cluster:\n\nSeurat::FeaturePlot(seu, \"HBA1\")\n\n\n\n\n\n\n\nBased on expression of sets of genes you can do a manual cell type annotation. If you know the marker genes for some cell types, you can check whether they are up-regulated in one or the other cluster. Here we have some marker genes for two different cell types:\n\ntcell_genes &lt;- c(\"IL7R\", \"LTB\", \"TRAC\", \"CD3D\")\nmonocyte_genes &lt;- c(\"CD14\", \"CST3\", \"CD68\", \"CTSS\")\n\nLet’s have a look at the expression of the four T cell genes:\n\nSeurat::FeaturePlot(seu, tcell_genes, ncol=2)\n\n\n\n\n\n\n\nThese cells are almost all in cluster 0 and 8. Which becomes clearer when looking at the violin plot:\n\nSeurat::VlnPlot(seu,\n                features = tcell_genes,\n                ncol = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nHave a look at the monocyte genes as well. Which clusters contain probably monocytes?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nSeurat::FeaturePlot(seu, monocyte_genes, ncol=2)\n\n\n\n\n\n\n\n\nSeurat::VlnPlot(seu,\n                features = monocyte_genes,\n                ncol = 2)\n\n\n\n\n\n\n\n\n\n\nWe can also automate this with the function AddModuleScore. For each cell, an expression score for a group of genes is calculated:\n\nseu &lt;- Seurat::AddModuleScore(seu,\n                              features = list(tcell_genes),\n                              name = \"tcell_genes\")\n\n\n\n\n\n\n\nExercise\n\n\n\nAfter running AddModuleScore, a column was added to seu@meta.data.\nA. What is the name of that column? What kind of data is in there?\nB. Generate a UMAP with color accoding to this column and a violinplot grouped by cluster. Is this according to what we saw in the previous exercise?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nA. The new column is called tcell_genes1. It contains the module score for each cell (which is basically the average expression of the set of genes).\nB. You can plot the UMAP with\n\nSeurat::FeaturePlot(seu, \"tcell_genes1\")\n\n\n\n\n\n\n\nWhich indeed shows these genes are mainly expressed in clusters 0 and 8:\n\nSeurat::VlnPlot(seu,\n                \"tcell_genes1\")\n\n\n\n\n\n\n\n\n\n\nAnnotating cells according to cycling phase\nBased on the same principle, we can also annotate cell cycling state. The function CellCycleScore uses AddModuleScore to get a score for the G2/M and S phase (the mitotic phases in which cell is cycling). In addition, CellCycleScore assigns each cell to either the G2/M, S or G1 phase.\nFirst we extract the built-in genes for cell cycling:\n\ns.genes &lt;- Seurat::cc.genes.updated.2019$s.genes\ng2m.genes &lt;- Seurat::cc.genes.updated.2019$g2m.genes\n\nNow we run the function:\n\nseu &lt;- Seurat::CellCycleScoring(seu,\n                                s.features = s.genes,\n                                g2m.features = g2m.genes)\n\nAnd we can visualize the annotations:\n\nSeurat::DimPlot(seu, group.by = \"Phase\")\n\n\n\n\n\n\n\nBased on your application, you can try to regress out the cell cycling scores at the step of scaling. Reasons for doing that could be:\n\nMerging cycling and non-cycling cells of the same type in one cluster\nMerging G2/M and S phase in one cluster\n\n\n\n\n\n\n\nNote\n\n\n\nNote that correcting for cell cycling is performed at the scaling step. It will therefore only influence analyses that use scaled data, like dimensionality reduction and clustering. For e.g. differential gene expression testing, we use the raw original counts (not scaled).\n\n\nHere, we choose not to regress out either of them. Because we are looking at developing cells, we might be interested to keep cycling cells seperated. In addition, the G2/M and S phases seem to be in the same clusters. More info on correcting for cell cycling here.\nCell type annotation using SingleR\n\nTo do a fully automated annoation, we need a reference dataset of primary cells. Any reference could be used. The package scRNAseq in Bioconductor includes several scRNAseq datasets that can be used as reference to SingleR. One could also use a reference made of bulk RNA seq data. Here we are using the a hematopoietic reference dataset from celldex. Check out what’s in there:\n\nref &lt;- celldex::NovershternHematopoieticData()\nclass(ref)\ntable(ref$label.main)\n\n\n\n\n\n\n\nNote\n\n\n\nYou will be asked whether to create the directory /home/rstudio/.cache/R/ExperimentHub. Type yes as a response.\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou can find more information on different reference datasets at the celldex documentation\n\n\nNow SingleR compares our normalized count data to a reference set, and finds the most probable annation:\n\nseu_SingleR &lt;- SingleR::SingleR(test = Seurat::GetAssayData(seu),\n                                ref = ref,\n                                labels = ref$label.main)\n\nSee what’s in there by using head:\n\nhead(seu_SingleR)\n\nDataFrame with 6 rows and 4 columns\n                                                   scores          labels\n                                                 &lt;matrix&gt;     &lt;character&gt;\nPBMMC-1_AAACCTGCAGACGCAA-1 0.216202:0.197296:0.086435:...         B cells\nPBMMC-1_AAACCTGTCATCACCC-1 0.143005:0.129582:0.170521:...    CD8+ T cells\nPBMMC-1_AAAGATGCATAAAGGT-1 0.113423:0.196264:0.111341:...       Monocytes\nPBMMC-1_AAAGCAAAGCAGCGTA-1 0.166749:0.168504:0.239303:...    CD4+ T cells\nPBMMC-1_AAAGCAACAATAACGA-1 0.102549:0.103979:0.178762:...    CD8+ T cells\nPBMMC-1_AAAGCAACATCAGTCA-1 0.181526:0.147693:0.115841:... Erythroid cells\n                           delta.next   pruned.labels\n                            &lt;numeric&gt;     &lt;character&gt;\nPBMMC-1_AAACCTGCAGACGCAA-1  0.1471065         B cells\nPBMMC-1_AAACCTGTCATCACCC-1  0.0753696    CD8+ T cells\nPBMMC-1_AAAGATGCATAAAGGT-1  0.1274524       Monocytes\nPBMMC-1_AAAGCAAAGCAGCGTA-1  0.0845267    CD4+ T cells\nPBMMC-1_AAAGCAACAATAACGA-1  0.0607683    CD8+ T cells\nPBMMC-1_AAAGCAACATCAGTCA-1  0.1057135 Erythroid cells\n\n\nVisualize singleR score quality scores:\n\nSingleR::plotScoreHeatmap(seu_SingleR)\n\n\n\n\n\n\n\n\nSingleR::plotDeltaDistribution(seu_SingleR)\n\nWarning: Groups with fewer than two datapoints have been dropped.\nℹ Set `drop = FALSE` to consider such groups for position adjustment purposes.\n\n\nWarning in max(data$density, na.rm = TRUE): no non-missing arguments to max;\nreturning -Inf\n\n\nWarning: Computation failed in `stat_ydensity()`.\nCaused by error in `$&lt;-.data.frame`:\n! replacement has 1 row, data has 0\n\n\nWarning in min(x): no non-missing arguments to min; returning Inf\n\n\nWarning in max(x): no non-missing arguments to max; returning -Inf\n\n\nWarning in min(d[d &gt; tolerance]): no non-missing arguments to min; returning\nInf\n\n\n\n\n\n\n\n\nThere are some annotations that contain only a few cells. They are usually not of interest, and they clogg our plots. Therefore we remove them from the annotation:\n\nsingleR_labels &lt;- seu_SingleR$labels\nt &lt;- table(singleR_labels)\nother &lt;- names(t)[t &lt; 10]\nsingleR_labels[singleR_labels %in% other] &lt;- \"none\"\n\nIn order to visualize it in our UMAP, we have to add the annotation to seu@meta.data:\n\nseu$SingleR_annot &lt;- singleR_labels\n\nWe can plot the annotations in the UMAP. Here, we use a different package for plotting (dittoSeq) as it has a bit better default coloring, and some other plotting functionality we will use later on.\n\ndittoSeq::dittoDimPlot(seu, \"SingleR_annot\", size = 0.7)\n\n\n\n\n\n\n\nWe can check out how many cells per sample we have for each annotated cell type:\n\ndittoSeq::dittoBarPlot(seu, var = \"SingleR_annot\", group.by = \"orig.ident\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCompare our manual annotation (based on the set of T cell genes) to the annotation with SingleR. Do they correspond?\n\n\n\nYou can for example use the plotting function dittoBarPlot to visualize the cell types according to cluster (use RNA_snn_res.0.3 in stead of orig.ident))\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nWe can have a look at the mean module score for each SingleR annotation like this:\n\ndittoSeq::dittoBarPlot(seu, \n                       var = \"SingleR_annot\", \n                       group.by = \"RNA_snn_res.0.3\")\n\n\n\n\n\n\n\nHere, you can see that cluster 0 and 8 contain cells annotated as T cells (CD4+ and CD8+).\n\n\n\nSave the dataset and clear environment\nNow, save the dataset so you can use it tomorrow:\n\nsaveRDS(seu, \"day3/seu_day3-1.rds\")\n\nFound more than one class \"package_version\" in cache; using the first, from namespace 'SeuratObject'\n\n\nAlso defined by 'alabaster.base'\n\n\nFound more than one class \"package_version\" in cache; using the first, from namespace 'SeuratObject'\n\n\nAlso defined by 'alabaster.base'\n\n\nClear your environment:\n\nrm(list = ls())\ngc()\n.rs.restartR()"
  },
  {
    "objectID": "day3/day3-3_enrichment_analysis.html",
    "href": "day3/day3-3_enrichment_analysis.html",
    "title": "Enrichment analysis",
    "section": "",
    "text": "Download the presentation \n\nMSigDB\n\nclusterProfiler vignette\n\nRevigo\nSignaling Pathway Impact Analysis (SPIA)\nOriginal paper on GSEA\n\nSTRING for protein-protein interactions\n\nGO figure! for plotting GO terms and the associated paper\nLet’s select a set of genes that are downregulated in the tumor cells compared to normal:\ntum_down  &lt;- subset(limma_de,\n                    limma_de$logFC &lt; -1 \n                      & limma_de$adj.P.Val &lt;  0.05)\ntum_down_genes &lt;- rownames(tum_down)\nWe can do a Gene Ontology term over-representation analysis based on this set of genes. Make sure you check out the help of this function to understand its arguments:\n?enrichGO\ntum_vs_norm_go &lt;- clusterProfiler::enrichGO(tum_down_genes,\n                                            \"org.Hs.eg.db\",\n                                            keyType = \"SYMBOL\",\n                                            ont = \"BP\",\n                                            minGSSize = 50)\nThe results are stored in the @result slot:\nView(tum_vs_norm_go@result)\nID\nDescription\nGeneRatio\nBgRatio\nRichFactor\nFoldEnrichment\nzScore\n\n\n\nGO:0007059\nGO:0007059\nchromosome segregation\n105/804\n434/18860\n0.2419355\n5.675253\n20.79271\n\n\nGO:0000070\nGO:0000070\nmitotic sister chromatid segregation\n65/804\n192/18860\n0.3385417\n7.941413\n20.39981\n\n\nGO:0098813\nGO:0098813\nnuclear chromosome segregation\n82/804\n323/18860\n0.2538700\n5.955209\n18.95484\n\n\nGO:0000819\nGO:0000819\nsister chromatid segregation\n70/804\n233/18860\n0.3004292\n7.047381\n19.59975\n\n\nGO:0140014\nGO:0140014\nmitotic nuclear division\n73/804\n281/18860\n0.2597865\n6.093996\n18.15420\n\n\nGO:0000280\nGO:0000280\nnuclear division\n90/804\n453/18860\n0.1986755\n4.660473\n16.64069\nSome GO terms seem redundant because they contain many of the same genes, which is a characteristic of Gene Ontology gene sets. We can simplify this list by removing redundant gene sets:\nenr_go &lt;- clusterProfiler::simplify(tum_vs_norm_go)\nView(enr_go@result)\nID\nDescription\nGeneRatio\nBgRatio\nRichFactor\nFoldEnrichment\nzScore\n\n\n\nGO:0007059\nGO:0007059\nchromosome segregation\n105/804\n434/18860\n0.2419355\n5.675253\n20.79271\n\n\nGO:0000070\nGO:0000070\nmitotic sister chromatid segregation\n65/804\n192/18860\n0.3385417\n7.941413\n20.39981\n\n\nGO:0098813\nGO:0098813\nnuclear chromosome segregation\n82/804\n323/18860\n0.2538700\n5.955209\n18.95484\n\n\nGO:0000280\nGO:0000280\nnuclear division\n90/804\n453/18860\n0.1986755\n4.660473\n16.64069\n\n\nGO:1905818\nGO:1905818\nregulation of chromosome separation\n32/804\n76/18860\n0.4210526\n9.876931\n16.36260\n\n\nGO:1901987\nGO:1901987\nregulation of cell cycle phase transition\n75/804\n468/18860\n0.1602564\n3.759249\n12.75486\nWe can quite easily generate a plot called an enrichment map with the enrichplot package:\nenrichplot::emapplot(enrichplot::pairwise_termsim(enr_go),\n                     showCategory = 30)\nInstead of testing for Gene Ontology terms, we can also test for other gene set collections. For example the Hallmark collection from MSigDB:\nlibrary(msigdbr)\nlibrary(msigdbdf)\ngmt &lt;- msigdbr::msigdbr(species = \"human\", category = \"H\")\n\nWarning: The `category` argument of `msigdbr()` is deprecated as of msigdbr 10.0.0.\nℹ Please use the `collection` argument instead.\nWe can use the function enricher to test for over-representation of any set of genes of the Hallmark collection. We have to include the “universe”, i.e. the full list of background, non significant genes, against which to test for differences in proportions:\ntum_vs_norm_enrich &lt;- clusterProfiler::enricher(gene = tum_down_genes,\n                                                universe = rownames(proB),\n                                                pAdjustMethod = \"BH\",\n                                                pvalueCutoff  = 0.05,\n                                                qvalueCutoff  = 0.05,\n                                                TERM2GENE = gmt[,c(\"gs_name\", \"gene_symbol\")])\nWhen using the genes down-regulated in tumor, among the over-represented Hallmark gene sets, we have HALLMARK_G2M_CHECKPOINT, which includes genes involved in the G2/M checkpoint in the progression through the cell division cycle.\nView(tum_vs_norm_enrich@result[tum_vs_norm_enrich@result$p.adjust &lt; 0.05,])\nID\nDescription\nGeneRatio\nBgRatio\nRichFactor\nFoldEnrichment\nzScore\n\n\n\nHALLMARK_E2F_TARGETS\nHALLMARK_E2F_TARGETS\nHALLMARK_E2F_TARGETS\n80/344\n195/3857\n0.4102564\n4.599881\n16.141910\n\n\nHALLMARK_G2M_CHECKPOINT\nHALLMARK_G2M_CHECKPOINT\nHALLMARK_G2M_CHECKPOINT\n67/344\n187/3857\n0.3582888\n4.017209\n13.234324\n\n\nHALLMARK_MITOTIC_SPINDLE\nHALLMARK_MITOTIC_SPINDLE\nHALLMARK_MITOTIC_SPINDLE\n48/344\n197/3857\n0.2436548\n2.731909\n7.807757\n\n\nHALLMARK_MYC_TARGETS_V1\nHALLMARK_MYC_TARGETS_V1\nHALLMARK_MYC_TARGETS_V1\n33/344\n193/3857\n0.1709845\n1.917113\n4.090088\n\n\nHALLMARK_ESTROGEN_RESPONSE_LATE\nHALLMARK_ESTROGEN_RESPONSE_LATE\nHALLMARK_ESTROGEN_RESPONSE_LATE\n28/344\n164/3857\n0.1707317\n1.914280\n3.743863"
  },
  {
    "objectID": "day3/day3-3_enrichment_analysis.html#material",
    "href": "day3/day3-3_enrichment_analysis.html#material",
    "title": "Enrichment analysis",
    "section": "",
    "text": "Download the presentation \n\nMSigDB\n\nclusterProfiler vignette\n\nRevigo\nSignaling Pathway Impact Analysis (SPIA)\nOriginal paper on GSEA\n\nSTRING for protein-protein interactions\n\nGO figure! for plotting GO terms and the associated paper"
  },
  {
    "objectID": "day3/day3-3_enrichment_analysis.html#exercises",
    "href": "day3/day3-3_enrichment_analysis.html#exercises",
    "title": "Enrichment analysis",
    "section": "Exercises",
    "text": "Exercises\n\ntum_vs_norm &lt;- readRDS(\"day3/tum_vs_norm_day3-2.rds\")\nlimma_de &lt;- readRDS(\"day3/limma_de_day3-2.rds\")\nproB &lt;- readRDS(\"day3/proB_day3-2.rds\")\n\nLoad the following packages:\n\nlibrary(clusterProfiler)\nlibrary(ggiraph)\nlibrary(enrichplot)\n\nIf the FindMarkers or FindAllMarkers functions were used, we obtained a table listing only the significant genes, but we don’t have any information of fold change for the non-significant genes. Therefore, we can use the over-representation analysis which is a threshold-based method. Using our list of significant genes, we can test if any gene set is over-represented among significant genes or not using a test similar to a Fisher test to compare differences in proportions.\nThe clusterProfiler package provides functions for over-representation analysis of Gene Ontology gene sets (among other functions, including functions for actual GSEA) or KEGG gene sets.\nGenes can be labeled using different types of labels, eg symbol, Ensembl ID, Entrez ID. To list the allowed label types use:\n\n# BiocManager::install(\"org.Hs.eg.db\", update = FALSE)\nlibrary(org.Hs.eg.db)\nAnnotationDbi::keytypes(org.Hs.eg.db)"
  },
  {
    "objectID": "day3/day3-3_enrichment_analysis.html#about-orgdb",
    "href": "day3/day3-3_enrichment_analysis.html#about-orgdb",
    "title": "Enrichment analysis",
    "section": "About OrgDb",
    "text": "About OrgDb\nFor other organisms, you can find available OrgDbs at bioconductor"
  },
  {
    "objectID": "precourse_preparations.html",
    "href": "precourse_preparations.html",
    "title": "Precourse preparations",
    "section": "",
    "text": "Participants should already have a basic knowledge in Next Generation Sequencing (NGS) techniques, or have already followed the course NGS - Quality control, Alignment, Visualisation. Knowledge in RNA sequencing is a plus. A basic knowledge of the R statistical software is required. Test your R skills with the quiz here, before registering. If you are not familiar with NGS techniques, we highly recommend reviewing the NGS introduction training materials to ensure a smoother learning experience in this course."
  },
  {
    "objectID": "precourse_preparations.html#required-competences",
    "href": "precourse_preparations.html#required-competences",
    "title": "Precourse preparations",
    "section": "",
    "text": "Participants should already have a basic knowledge in Next Generation Sequencing (NGS) techniques, or have already followed the course NGS - Quality control, Alignment, Visualisation. Knowledge in RNA sequencing is a plus. A basic knowledge of the R statistical software is required. Test your R skills with the quiz here, before registering. If you are not familiar with NGS techniques, we highly recommend reviewing the NGS introduction training materials to ensure a smoother learning experience in this course."
  },
  {
    "objectID": "precourse_preparations.html#software",
    "href": "precourse_preparations.html#software",
    "title": "Precourse preparations",
    "section": "Software",
    "text": "Software\nAttendees should have a Wi-Fi enabled computer. An online R and RStudio environment will be provided. In order to access that environment your computer needs to be able to access http websites (not https). You can check this by browsing to http://www.httpforever.com. However, in case you wish to perform the practical exercises on your own computer, please take a moment to install the following before the course:\n\nR version &gt; 4.0.\nLatest RStudio version, the free version is perfectly fine.\nThe R packages necessary for the course. Find the script to install them here."
  },
  {
    "objectID": "precourse_preparations.html#project-data-and-memory-considerations",
    "href": "precourse_preparations.html#project-data-and-memory-considerations",
    "title": "Precourse preparations",
    "section": "Project Data and Memory Considerations",
    "text": "Project Data and Memory Considerations\nSome of the project datasets used in this course can be quite large and may require significant computational resources (RAM). If you are running the exercises on your local machine and encounter memory issues, consider the following strategies:\n\nDownsampling: For initial exploration and testing of code, you can downsample your dataset to a smaller number of cells or genes. This will reduce memory usage and speed up computations.\nCloud Resources: If you consistently face memory limitations, consider utilizing cloud-based computational environments that offer more RAM and processing power.\nClose unnecessary applications: Ensure that no other memory-intensive applications are running in the background while you are working on the course exercises.\nMonitor memory usage: Use system monitoring tools to keep an eye on your RAM usage. This can help you identify when and where memory bottlenecks occur."
  },
  {
    "objectID": "projects/project1.html",
    "href": "projects/project1.html",
    "title": "Project 1",
    "section": "",
    "text": "Project 1 is about a single cell sequencing project of zebrafish retina. Photoreceptors were damaged with MNU and the response was investigated with help of transgenic fish that contained contstruct with a non-coding element (careg) regulating attached to a EGFP transcript, that can be used as regenerative activation marker. For single-cell transcriptomics analysis, cell suspensions were created from retinal cells, and processed with the 10x 3’ kit."
  },
  {
    "objectID": "projects/project1.html#available-data",
    "href": "projects/project1.html#available-data",
    "title": "Project 1",
    "section": "Available data",
    "text": "Available data\nData has been downloaded and prepared for you from GEO GSE202212. The count matrices are created with cellranger. To create the count tables, the EGFP sequence was added to the reference genome. The gene name of EGFP is EGFP.\nIn order to download the data, run:\n\nwget https://single-cell-transcriptomics.s3.eu-central-1.amazonaws.com/projects/data/project1.tar.gz\ntar -xvf project1.tar.gz\nrm project1.tar.gz \n\nAfter extracting, a directory project1 appears with the following content:\n.\n├── data\n│   ├── 10dp1\n│   │   ├── filtered_feature_bc_matrix\n│   │   │   ├── barcodes.tsv.gz\n│   │   │   ├── features.tsv.gz\n│   │   │   └── matrix.mtx.gz\n│   │   └── web_summary.html\n│   ├── 10dp2\n│   │   ├── filtered_feature_bc_matrix\n│   │   │   ├── barcodes.tsv.gz\n│   │   │   ├── features.tsv.gz\n│   │   │   └── matrix.mtx.gz\n│   │   └── web_summary.html\n│   ├── 3dp1\n│   │   ├── filtered_feature_bc_matrix\n│   │   │   ├── barcodes.tsv.gz\n│   │   │   ├── features.tsv.gz\n│   │   │   └── matrix.mtx.gz\n│   │   └── web_summary.html\n│   ├── 3dp2\n│   │   ├── filtered_feature_bc_matrix\n│   │   │   ├── barcodes.tsv.gz\n│   │   │   ├── features.tsv.gz\n│   │   │   └── matrix.mtx.gz\n│   │   └── web_summary.html\n│   ├── 7dp1\n│   │   ├── filtered_feature_bc_matrix\n│   │   │   ├── barcodes.tsv.gz\n│   │   │   ├── features.tsv.gz\n│   │   │   └── matrix.mtx.gz\n│   │   └── web_summary.html\n│   ├── 7dp2\n│   │   ├── filtered_feature_bc_matrix\n│   │   │   ├── barcodes.tsv.gz\n│   │   │   ├── features.tsv.gz\n│   │   │   └── matrix.mtx.gz\n│   │   └── web_summary.html\n│   ├── ctrl1\n│   │   ├── filtered_feature_bc_matrix\n│   │   │   ├── barcodes.tsv.gz\n│   │   │   ├── features.tsv.gz\n│   │   │   └── matrix.mtx.gz\n│   │   └── web_summary.html\n│   └── ctrl2\n│       ├── filtered_feature_bc_matrix\n│       │   ├── barcodes.tsv.gz\n│       │   ├── features.tsv.gz\n│       │   └── matrix.mtx.gz\n│       └── web_summary.html\n└── paper.pdf\n\n17 directories, 33 files\nShowing us that we have two replicates per treatment, and four treatments:\n\nctrl: controls\n3dp: 3 days post injury\n7dp: 7 days post injury\n10dp: 10 days post injury\n\nNow create a new project in the project1 directory (Project (None) &gt; New Project …), and create Seurat object from the count matrices:\n\nlibrary(Seurat)\n\n# vector of paths to all sample directories\ndatadirs &lt;- list.files(path = \"data\", full.names = TRUE) \n\n# get the sample names\n# replace underscores with hyphen to correctly extract sample names later on\nsamples &lt;- basename(datadirs) |&gt; gsub(\"_\", \"-\", x = _)\n\n# files are in filter_feature_bc_matrix\ndatadirs &lt;- paste(datadirs, \"filtered_feature_bc_matrix\", sep = \"/\")\n\nnames(datadirs) &lt;- samples\n\n# create a large sparse matrix from all count data\nsparse_matrix &lt;- Seurat::Read10X(data.dir = datadirs)\n\n# create a seurat object from sparse matrix\nseu &lt;- Seurat::CreateSeuratObject(counts = sparse_matrix,\n                                  project = \"Zebrafish\")\n\n\n\n\n\n\n\nProject exercise\n\n\n\nWith this dataset, go through the steps we have performed during the course, and try to answer the following questions. Pay specific attention to quality control, clustering and annotation."
  },
  {
    "objectID": "projects/project1.html#guidance-questions",
    "href": "projects/project1.html#guidance-questions",
    "title": "Project 1",
    "section": "Guidance questions",
    "text": "Guidance questions\nIf you’d like more structure, the following questions may guide your analyses:\nQuality control and filtering\n\nHave a look at the seurat object before starting your analysis. How many cells and genes are present? Is the data already normalised?\nAssess the quality of the samples. Are there any important issues to consider? Would you remove genes?\nNormalization, integration and visualization\n\nWhich clustering resolution would you choose?\nInspect the clustering (ie. % of mitochondrial, number of features..), would you filter out some populations? do you need to change your resolution?\nCell type annotation\n\nAnnotate cells (at least rods, cons and MG) and describe EGFP behavior in the different conditions (Ctr, 3dp, 7dp, 10dp)\nCan you identify a subpopulation of MG cells expression EGFP?\n\n\n\n\n\n\n\nBonus questions (advanced)\n\n\n\n\n\n\nCan you identify expression profile differences in injured vs uninjured Rods cells? and in Cons cells?\nHow do your results compare to the ones from the paper?"
  },
  {
    "objectID": "projects/project1.html#additional-tips",
    "href": "projects/project1.html#additional-tips",
    "title": "Project 1",
    "section": "Additional tips",
    "text": "Additional tips\n\nFor mitochondrial genes, ribosomal genes and hemoglobin genes you can use the following patterns: \"^mt-\", \"^rp[sl]\" and \"^hb[^(p)]\".\nWork iterative; meaning that based on results of an analsyis, adjust the previous analysis. For example, if clustering is not according to cell types, try to adjust the number of components or the resolution.\nYou can plot the samples by condition (keeping the 2 replicates together). For that, try adding a new metadata column that summarises the information you need.\nFor cell type annotation, have a look at the methods section from the original paper, they provide a supplementary table with retina gene markers."
  },
  {
    "objectID": "projects/project3.html",
    "href": "projects/project3.html",
    "title": "Project 3",
    "section": "",
    "text": "Project 3 focuses on understanding the role of type I interferon (IFN-I) responsiveness in shaping immune outcomes following PD1 blockade therapy; paper. Type I interferons are central regulators of anti-tumor immunity and responses to immunotherapy, but they also drive the feedback inhibition underlying therapeutic resistance. To investigate how pre-existing IFN-I responses influence therapeutic success, this study utilizes scRNA-seq data from healthy donors and 8 treated patients to analyze transcriptional responses in immune cells.\nUnsupervised clustering of transcriptional profiles revealed distinct immune cell populations and IFN-I-induced responses. Differences in IFN-I responsiveness were linked to immune cell states and transcriptional programs that influence therapy outcomes. Patients with lower pre-therapy IFN-I responsiveness in CD4 and CD8 effector T cells (Teff cells) exhibited transcriptional signatures associated with improved immune function, whereas highly responsive Teff cells displayed gene expression patterns linked to immune dysfunction and therapy resistance.\nFurther analysis identified epigenetically imprinted IFN-I response states that predefine immune reactivity to therapy. Coexpression and network analyses demonstrated that IFN-I responsiveness influences functional T cell programs and systemic immune coordination. This study provides insights into how pre-existing immune states impact therapeutic success and highlights transcriptional markers that could be used to predict patient outcomes in PD1 blockade immunotherapy."
  },
  {
    "objectID": "projects/project3.html#available-data",
    "href": "projects/project3.html#available-data",
    "title": "Project 3",
    "section": "Available data",
    "text": "Available data\nData has been downloaded and prepared for you from GEO GSE199994.\nIn order to download the data, run:\n\nwget https://single-cell-transcriptomics.s3.eu-central-1.amazonaws.com/projects/data/project3.tar.gz\n\ntar -xzvf project3.tar.gz\n\nAfter extracting, a directory GSE199994 appears with the following format:\nGSE199994/\n├── data\n│   ├── HD1\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── HD2\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── P1\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── P2\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── P3\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── P4\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── P5\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── P6\n│   │   ├── barcodes.tsv.gz\n│   │   ├── features.tsv.gz\n│   │   └── matrix.mtx.gz\n│   ├── P7\n   │   ├── barcodes.tsv.gz\n   │   ├── features.tsv.gz\n   │   └── matrix.mtx.gz\n   └── P8\n       ├── barcodes.tsv.gz\n       ├── features.tsv.gz\n       └── matrix.mtx.gz\n└── paper.pdf\nShowing us that we have two healthy donors (HD) and eight treated patients (P).\nNow create a new project in the project3 directory (Project (None) &gt; New Project …), and create a combined Seurat object from all the count matrices:\n\nlibrary(Seurat)\n\n# vector of paths to all sample directories\ndatadirs &lt;- list.files(path = \"project3/data\", full.names = TRUE)\n\n# get the sample names and replace underscores with hyphens\nnames(datadirs) &lt;- basename(datadirs) |&gt; gsub(\"_\", \"-\", x = _)\n\n# create a large sparse matrix from all count data\nsparse_matrix &lt;- Seurat::Read10X(data.dir = datadirs)\n\n# create a seurat object from sparse matrix\nseu &lt;- Seurat::CreateSeuratObject(counts = sparse_matrix,\nproject = \"InterferonStudy\")\n\n\n\n\n\n\n\nProject exercise\n\n\n\nWith this dataset, go through the steps we have performed during the course, and try to reproduce the results provided in the paper."
  },
  {
    "objectID": "projects/project3.html#guidance-questions",
    "href": "projects/project3.html#guidance-questions",
    "title": "Project 3",
    "section": "Guidance questions",
    "text": "Guidance questions\nIf you’d like more structure, the following questions may guide your analyses:\n1. Quality Control (QC)\nThe paper’s methods for filtering were primarily based on mass cytometry (CyTOF) data. For your scRNA-seq data, you should apply standard QC metrics to filter out low-quality cells and genes using the subset function in Seurat.\n\n\nMitochondrial Genes: Use the pattern \"^MT-\" to calculate the percentage of mitochondrial reads (PercentageFeatureSet).\n\nRibosomal Genes: Use the pattern \"^RP[SL]\" to calculate the percentage of ribosomal reads.\n\nHemoglobin Genes: Use the pattern \"^HB[^(P)]\" to calculate the percentage of hemoglobin reads.\n\nFiltering: Use the subset function to filter cells based on the number of features (nFeature_RNA), UMI counts (nCount_RNA), and the calculated percentages of mitochondrial, ribosomal, and hemoglobin reads.\n2. Data Normalization and Scaling\nThe paper used arcsinh transformation for their protein expression data. For your scRNA-seq data, you should use SCTransform to regress out unwanted variation.\n\n\nReproduce:\n\nUse the SCTransform() function to normalize and scale the data and to regress out confounding factors like the number of UMIs (nFeature_RNA). The paper mentions using scTransform residuals for differential expression calculation, so this method is highly relevant.\n\n\n3. Dimensionality Reduction\nThe paper used UMAP for visualization. For this, you will first need to perform a linear dimensionality reduction.\n\n\nReproduce:\n\nRun PCA on the scaled data using the RunPCA() function.\nUse an Elbow Plot (ElbowPlot()) to determine the appropriate number of principal components.\nRun UMAP on the selected principal components using the RunUMAP() function to visualize the data in 2D.\n\n\n4. Unsupervised Clustering\nThe paper used the fast-PhenoGraph algorithm for clustering and identified 39 distinct clusters in their ex vivo dataset.\n\n\nReproduce:\n\nFind the nearest neighbors using FindNeighbors().\nApply the clustering algorithm using FindClusters(). You can adjust the resolution parameter to identify a similar number of clusters as reported in the paper. A resolution between 0.5 and 1.0 is a good starting point.\n\n\n5. Cluster Annotation\nAnnotate your clusters by identifying top marker genes for each cluster. The paper manually classified clusters based on lineage marker expression.\n\n\nReproduce:\n\nUse the FindAllMarkers() function to find marker genes for each cluster. You can set min.pct = 0.25 and logfc.threshold = 0.25 as a starting point.\nFilter the marker genes (e.g., based on adjusted p-value) and use known canonical markers to assign cell type labels to your clusters.\n\n\n6. Differential Expression (DE) and IFN-I Response Analysis\nA core part of the paper’s analysis is the IFN-I response capacity (IRC) score, which was based on the expression of a core set of IFN-I-stimulated proteins (ISPs). The paper also used the Wilcoxon’s rank-sum test for statistical testing.\n\n\nIFN-I Response Score: To replicate this using gene expression data, you can use Seurat’s AddModuleScore() function. The paper used the ISPs BST2, PKR, ISG15, MX1, IFIT3, and IRF7. You can use the corresponding genes to define your ISG gene list.\n\nDifferential Expression: Use the FindMarkers() function to compare gene expression between groups (e.g., patients with high vs. low IFN-I responsiveness). You should specify test.use = \"wilcox\" for the Wilcoxon’s rank-sum test.\n7. Comparison of Patient Groups\nThe paper’s key finding relates IFN-I responsiveness to therapy outcome.\n\n\nReproduce:\n\nAfter calculating the IFN-I response score, classify patient cells into high and low IFN-I responsive groups based on their scores. A common approach is to use the median or a quantile-based cutoff.\nPerform a differential expression analysis between these two groups within specific cell clusters to identify gene expression patterns associated with improved or poor outcomes.\n\n\n8. Pathway Enrichment Analysis\nThe paper used Gene Set Enrichment Analysis (GSEA) and Ingenuity Pathway Analysis (IPA). You can use the R package clusterProfiler for this task.\n\n\nReproduce:\n\nTake the list of differentially expressed genes from your DE analysis.\nPerform a pathway enrichment analysis using clusterProfiler to identify affected biological pathways. You can use functions like enrichGO for Gene Ontology enrichment."
  },
  {
    "objectID": "projects/project3.html#additional-tips",
    "href": "projects/project3.html#additional-tips",
    "title": "Project 3",
    "section": "Additional tips",
    "text": "Additional tips\nKey Figures to Compare\nAs you work through the analysis, you can compare your results to the following figures from the paper:\n\n\nUMAP Plots: Compare your UMAP plots with Figure 1b and Figure 2a to check your clustering and visualization.\n\nIRC Score Plots: Compare the distributions of your calculated IFN-I response score across different cell populations to the violin plots in Figure 2d."
  }
]